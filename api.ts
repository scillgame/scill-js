/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * SCILL API
 * SCILL gives you the tools to activate, retain and grow your user base in your app or game by bringing you features well known in the gaming industry: Gamification. We take care of the services and technology involved so you can focus on your game and content.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@scillgame.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/4Players-GmbH/scill-gaas/1.0.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface ActionResponse
 */
export interface ActionResponse {
    /**
     * HTTP status code
     * @type {number}
     * @memberof ActionResponse
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ActionResponse
     */
    message: string;
}
/**
 * 
 * @export
 * @interface BattlePass
 */
export interface BattlePass {
    /**
     * The unique id of this battle pass.
     * @type {string}
     * @memberof BattlePass
     */
    battle_pass_id: string;
    /**
     * If you want to sell Battle Passes you can use this field to trigger in-app purchase products within your mobile app. You can set this value in the Admin Panel.
     * @type {string}
     * @memberof BattlePass
     */
    package_sku: string;
    /**
     * The name of the Battle Pass in the local language set in the request (see Setting Language). In the admin panel you can either create HTML content or plain text.
     * @type {string}
     * @memberof BattlePass
     */
    name: string;
    /**
     * The description of the Battle Pass in the local language set in the request (see Setting Language). In the admin panel you can either create HTML content or plain text.
     * @type {string}
     * @memberof BattlePass
     */
    description: string;
    /**
     * A short description in the local language you can use to teaser battle passes or implement “expand for more” functionality.
     * @type {string}
     * @memberof BattlePass
     */
    truncated_description: string;
    /**
     * The mobile sized image name. For example you can use image and image_desktop to build a srcset in HTML or use them and size manually where you need them.
     * @type {string}
     * @memberof BattlePass
     */
    image: string;
    /**
     * The desktop sized image name or URL
     * @type {string}
     * @memberof BattlePass
     */
    image_desktop: string;
    /**
     * The date (in iso format) when the Battle Pass starts. Tracking begins once this date is passed.
     * @type {string}
     * @memberof BattlePass
     */
    battle_pass_start_date: string;
    /**
     * The date (in iso format) when the Battle Pass ends. Tracking stops once the end is reached and users will not be able to progress further than what they have achieved up to that point.
     * @type {string}
     * @memberof BattlePass
     */
    battle_pass_end_date: string;
    /**
     * If the Battle Pass costs “money” you may want to route the user to a web site/page, where they can learn more about this battle pass. You can also use this field to route the user inside your application by providing a path or whatever works for you.
     * @type {string}
     * @memberof BattlePass
     */
    read_more_link: string;
    /**
     * Another field you can set in the admin panel. SCILL Play uses this field to show a specific page by name.
     * @type {string}
     * @memberof BattlePass
     */
    page_id: string;
    /**
     * This option is not available in all requests. It indicates if the user has completed this Battle Pass.
     * @type {boolean}
     * @memberof BattlePass
     */
    battle_pass_completed?: boolean;
    /**
     * Price for the Battle Pass. You can set this field in the Admin Panel. Often it makes sense to use Pricing functionality of in-app purchase APIs in the relevant eco system (Steam, AppStore, Google Play Store) to request the price, but if you don’t have access to that, you can use this field.
     * @type {string}
     * @memberof BattlePass
     */
    package_value_eur?: string;
    /**
     * The date in iso format when the user purchased/unlocked this Battle Pass.
     * @type {string}
     * @memberof BattlePass
     */
    purchased_at?: string;
    /**
     * Indicates that this Battle Pass can be purchased via in-app purchase. This can be set in the Admin Panel.
     * @type {boolean}
     * @memberof BattlePass
     */
    can_purchase_with_money?: boolean;
    /**
     * Indicates that this Battle Pass can be purchased with SCILL Coins. This can be set in the Admin Panel.
     * @type {boolean}
     * @memberof BattlePass
     */
    can_purchase_with_coins?: boolean;
    /**
     * An array of BattlePassLevel objects.
     * @type {Array<BattlePassLevel>}
     * @memberof BattlePass
     */
    levels?: Array<BattlePassLevel>;
}
/**
 * 
 * @export
 * @interface BattlePassLevel
 */
export interface BattlePassLevel {
    /**
     * Unique id of this BattlePassLevel object.
     * @type {string}
     * @memberof BattlePassLevel
     */
    battle_pass_level_id: string;
    /**
     * The position of the level inside the stack of levels. Every level in this array will have this value incremented by 1.
     * @type {number}
     * @memberof BattlePassLevel
     */
    level_priority: number;
    /**
     * Indicates if this level is completed, i.e. all challenges have been completed.
     * @type {boolean}
     * @memberof BattlePassLevel
     */
    completed: boolean;
    /**
     * If all challenges in this level have been completed and can be claimed, this flag is true. I.e. show a “Claim Reward” button if this is true.
     * @type {boolean}
     * @memberof BattlePassLevel
     */
    can_claim: boolean;
    /**
     * Levels need to be unlocked one after the other. You can decide if you already want to show users the challenges waiting behind a locked challenge or if you hide them to make it more exciting for the user to unlock the next level.
     * @type {boolean}
     * @memberof BattlePassLevel
     */
    unlocked: boolean;
    /**
     * Indicates if the reward for this level has already been claimed. Important: Users need to claim the reward to unlock the next level! Of course, you can also do that via REST-API automatically.
     * @type {boolean}
     * @memberof BattlePassLevel
     */
    claimed: boolean;
    /**
     * The description of the reward in the local language set in the request (see Setting Language). In the admin panel you can either create HTML content or plain text.
     * @type {string}
     * @memberof BattlePassLevel
     */
    reward_description: string;
    /**
     * The mobile sized image name of the reward. For example you can use reward_image and reward_image_desktop to build a srcset in HTML or use and size them manually where you need them. This can be freely set in the Admin Panel. Either indicates a local asset via name or you can also use a URL.
     * @type {string}
     * @memberof BattlePassLevel
     */
    reward_image: string;
    /**
     * The desktop sized image name of the reward. Either indicates a local asset via name or you can also use a URL.
     * @type {string}
     * @memberof BattlePassLevel
     */
    reward_image_desktop: string;
    /**
     * An array of BattlePassLevelChallenge objects.
     * @type {Array<BattlePassLevelChallenge>}
     * @memberof BattlePassLevel
     */
    challenges: Array<BattlePassLevelChallenge>;
}
/**
 * 
 * @export
 * @interface BattlePassLevelChallenge
 */
export interface BattlePassLevelChallenge {
    /**
     * The number of things a user needs to achieve until this challenge is completed.
     * @type {number}
     * @memberof BattlePassLevelChallenge
     */
    challenge_goal: number;
    /**
     * The name in the local language indicated what to do.
     * @type {string}
     * @memberof BattlePassLevelChallenge
     */
    name: string;
    /**
     * The current number of things the user already has achieved. Use this in combination with challenge_goal to calculate progress and to render a nice progress bar/indicator.
     * @type {number}
     * @memberof BattlePassLevelChallenge
     */
    current_challenge_amount: number;
    /**
     * Indicates if this challenge is completed. Once all challenges in a BattlePassLevel object are completed, the current level reward can be claimed and the next level is unlocked.
     * @type {boolean}
     * @memberof BattlePassLevelChallenge
     */
    completed: boolean;
    /**
     * Indicates if the challenge is active, thus tracking progress.
     * @type {boolean}
     * @memberof BattlePassLevelChallenge
     */
    active: boolean;
}
/**
 * 
 * @export
 * @interface BattlePassLevelId
 */
export interface BattlePassLevelId {
    /**
     * The level id, i.e. battle_pass_level_id of the BattlePassLevel object
     * @type {string}
     * @memberof BattlePassLevelId
     */
    battle_pass_level_id: string;
}
/**
 * 
 * @export
 * @interface Challenge
 */
export interface Challenge {
    /**
     * The unique id of this challenge. Every challenge is linked to a product.
     * @type {string}
     * @memberof Challenge
     */
    challenge_id?: string;
    /**
     * If this challenge is unlocked (i.e. active see type) then this is the unique id of the challenge assiociated to the user. Otherwise this is 0 or empty.
     * @type {string}
     * @memberof Challenge
     */
    user_challenge_id?: string;
    /**
     * The name of the challenge in the language set by the language parameter.
     * @type {string}
     * @memberof Challenge
     */
    challenge_name?: string;
    /**
     * The duration of the challenge in seconds. Challenges auto lock after time-out and need to be unlocked again.
     * @type {number}
     * @memberof Challenge
     */
    challenge_duration_time?: number;
    /**
     * The date this challenge should start. Use that field to create challenges that start in the future.
     * @type {string}
     * @memberof Challenge
     */
    live_date?: string;
    /**
     * Indicates how many “tasks” must be completed or done to complete this challenge.
     * @type {number}
     * @memberof Challenge
     */
    challenge_goal?: number;
    /**
     * Indicates how many tasks the user already has completed. Use this in combination with challenge_goal to render a nice progress bar.
     * @type {number}
     * @memberof Challenge
     */
    user_challenge_current_score?: number;
    /**
     * In the admin panel you can set a string representing an image. This can be a URL, but it can also be an image or texture that you have in your games asset database.
     * @type {string}
     * @memberof Challenge
     */
    challenge_icon?: string;
    /**
     * This is the HD variant of the challenge icon image. If you have a game, that runs on multiple platforms that could come in handy. Otherwise just leave blank.
     * @type {string}
     * @memberof Challenge
     */
    challenge_icon_hd?: string;
    /**
     * If this challenge can be only activated once per user this will be false. Otherwise this challenge will always be added to list of available challenges (see personal or alliance challenges).
     * @type {boolean}
     * @memberof Challenge
     */
    repeatable?: boolean;
    /**
     * Indicates the status of the challenge. This can be one of the following unlock: Challenge does not track anything. in-progress: Challenge is active and tracking. overtime: User did not manage to finish the challenge in time. unclaimed: The challenge has been completed but the reward has not yet been claimed. finished: The challenge has been successfully be completed and the reward has been claimed
     * @type {string}
     * @memberof Challenge
     */
    type?: string;
    /**
     * If the challenge reward has been claimed this is true otherwise its false.
     * @type {boolean}
     * @memberof Challenge
     */
    is_claimed?: boolean;
    /**
     * This is the timestamp the challenge has been unlocked.
     * @type {string}
     * @memberof Challenge
     */
    user_challenge_unlocked_at?: string;
    /**
     * This is the timestamp the challenge has been activated.
     * @type {string}
     * @memberof Challenge
     */
    user_challenge_activated_at?: string;
}
/**
 * 
 * @export
 * @interface ChallengeCategory
 */
export interface ChallengeCategory {
    /**
     * Indicates if this is the daily category, bringing up new challenges every day for the user to tackle.
     * @type {boolean}
     * @memberof ChallengeCategory
     */
    is_daily_category?: boolean;
    /**
     * In the admin panel you set the order of the categories. This is the position index and indicates the position within the categories array.
     * @type {number}
     * @memberof ChallengeCategory
     */
    category_position?: number;
    /**
     * A short name without special chars to make it easier to refer to a specific category (in code) that is language and id agnostic.
     * @type {string}
     * @memberof ChallengeCategory
     */
    category_slug?: string;
    /**
     * The name of the category in the local language set as the query parameter.
     * @type {string}
     * @memberof ChallengeCategory
     */
    category_name?: string;
    /**
     * Indicates how many “tasks” must be completed or done to complete this challenge.
     * @type {string}
     * @memberof ChallengeCategory
     */
    category_id?: string;
    /**
     * An array of Challenge objects.
     * @type {Array<Challenge>}
     * @memberof ChallengeCategory
     */
    challenges?: Array<Challenge>;
}
/**
 * This holds metadata and is specific to each event type. Please have a look at the documentation to learn which properties need to be set for the event-type you want to send.
 * @export
 * @interface EventMetaData
 */
export interface EventMetaData {
    /**
     * The object that is the source of the action
     * @type {string}
     * @memberof EventMetaData
     */
    action_object?: string;
    /**
     * The object that is the target of the action
     * @type {string}
     * @memberof EventMetaData
     */
    action_subject?: string;
    /**
     * The name of the action
     * @type {string}
     * @memberof EventMetaData
     */
    action_type?: string;
    /**
     * Number of ammonition used
     * @type {number}
     * @memberof EventMetaData
     */
    ammo_used?: number;
    /**
     * A general indicator for number of items (i.e. number of kills in kill-enemy event)
     * @type {number}
     * @memberof EventMetaData
     */
    amount?: number;
    /**
     * The number of ammonition gained
     * @type {number}
     * @memberof EventMetaData
     */
    amount_gained?: number;
    /**
     * The number of amminition given
     * @type {number}
     * @memberof EventMetaData
     */
    amount_given?: number;
    /**
     * The name of an animal
     * @type {string}
     * @memberof EventMetaData
     */
    animal_name?: string;
    /**
     * The \"health\" state of the armor
     * @type {number}
     * @memberof EventMetaData
     */
    armor?: number;
    /**
     * The id of the opponent team
     * @type {string}
     * @memberof EventMetaData
     */
    away_team_id?: string;
    /**
     * The score of the opponent team
     * @type {number}
     * @memberof EventMetaData
     */
    away_score?: number;
    /**
     * An integer value indicating the battle status (map it to an enum for example in your code)
     * @type {number}
     * @memberof EventMetaData
     */
    battle_status?: number;
    /**
     * The name of the bounty
     * @type {string}
     * @memberof EventMetaData
     */
    bounty_name?: string;
    /**
     * The id or name of a building
     * @type {string}
     * @memberof EventMetaData
     */
    building_id?: string;
    /**
     * The level of the building
     * @type {number}
     * @memberof EventMetaData
     */
    building_level?: number;
    /**
     * The name of the card
     * @type {string}
     * @memberof EventMetaData
     */
    card_type?: string;
    /**
     * The name of a character
     * @type {string}
     * @memberof EventMetaData
     */
    character_name?: string;
    /**
     * The id/name of a checkpint
     * @type {string}
     * @memberof EventMetaData
     */
    checkpoint_id?: string;
    /**
     * The x coordinate in your coordinate system, used for example to store position on a map
     * @type {number}
     * @memberof EventMetaData
     */
    coordinate_x?: number;
    /**
     * The y coordinate in your coordinate system, used for example to store position on a map
     * @type {number}
     * @memberof EventMetaData
     */
    coordinate_y?: number;
    /**
     * The name of a crew
     * @type {string}
     * @memberof EventMetaData
     */
    crew_name?: string;
    /**
     * The amount of damage
     * @type {number}
     * @memberof EventMetaData
     */
    damage_amount?: number;
    /**
     * The distance measured in any coordinate system of your choice. Please note: This is an integer field. If you need more precision multiple your floating point value with 1000 or so to keep the precision but storing it as an integer value
     * @type {number}
     * @memberof EventMetaData
     */
    distance?: number;
    /**
     * The duration in any unit you like
     * @type {number}
     * @memberof EventMetaData
     */
    duration?: number;
    /**
     * The effect id or name
     * @type {string}
     * @memberof EventMetaData
     */
    effect_id?: string;
    /**
     * The character type or name of an enemy
     * @type {string}
     * @memberof EventMetaData
     */
    enemy_character?: string;
    /**
     * The type of an enemy
     * @type {string}
     * @memberof EventMetaData
     */
    enemy_type?: string;
    /**
     * The event type
     * @type {string}
     * @memberof EventMetaData
     */
    event_type?: string;
    /**
     * The number of fuel consumed
     * @type {number}
     * @memberof EventMetaData
     */
    fuel_consumed?: number;
    /**
     * The health
     * @type {number}
     * @memberof EventMetaData
     */
    health?: number;
    /**
     * The type of a hit (i.e. head, torso, leg)
     * @type {string}
     * @memberof EventMetaData
     */
    hit_type?: string;
    /**
     * The id or name of your or the home team
     * @type {string}
     * @memberof EventMetaData
     */
    home_team_id?: string;
    /**
     * The score of your or the home team
     * @type {number}
     * @memberof EventMetaData
     */
    home_score?: number;
    /**
     * The id of an item
     * @type {string}
     * @memberof EventMetaData
     */
    item_id?: string;
    /**
     * The name of an item
     * @type {string}
     * @memberof EventMetaData
     */
    item_name?: string;
    /**
     * The type of an item
     * @type {string}
     * @memberof EventMetaData
     */
    item_type?: string;
    /**
     * The type of a kill
     * @type {string}
     * @memberof EventMetaData
     */
    kill_type?: string;
    /**
     * The position in a lap
     * @type {number}
     * @memberof EventMetaData
     */
    lap_position?: number;
    /**
     * The id of the level
     * @type {string}
     * @memberof EventMetaData
     */
    level_id?: string;
    /**
     * The name of a map
     * @type {string}
     * @memberof EventMetaData
     */
    map_name?: string;
    /**
     * The name of a section of a map
     * @type {string}
     * @memberof EventMetaData
     */
    map_section_name?: string;
    /**
     * The mission id
     * @type {string}
     * @memberof EventMetaData
     */
    mission_id?: string;
    /**
     * The name of the player character
     * @type {string}
     * @memberof EventMetaData
     */
    player_character?: string;
    /**
     * The id of a puzzle
     * @type {number}
     * @memberof EventMetaData
     */
    puzzle_id?: number;
    /**
     * The position within a race
     * @type {number}
     * @memberof EventMetaData
     */
    race_position?: number;
    /**
     * The realm
     * @type {string}
     * @memberof EventMetaData
     */
    realm?: string;
    /**
     * The time required involed in this event. I.e. in a reach-checkpoint event this could be the time in seconds required to reach that checkpoint from the last checkpoint.
     * @type {number}
     * @memberof EventMetaData
     */
    required_time?: number;
    /**
     * The name/id of the resource gained
     * @type {string}
     * @memberof EventMetaData
     */
    resource_gained?: string;
    /**
     * The name/id of the resource given (to someone else)
     * @type {string}
     * @memberof EventMetaData
     */
    resource_given?: string;
    /**
     * The name of the resource
     * @type {string}
     * @memberof EventMetaData
     */
    resource_name?: string;
    /**
     * The id of the round
     * @type {number}
     * @memberof EventMetaData
     */
    round_id?: number;
    /**
     * The type of the round
     * @type {string}
     * @memberof EventMetaData
     */
    round_type?: string;
    /**
     * The score
     * @type {number}
     * @memberof EventMetaData
     */
    score?: number;
    /**
     * The type of the stats item
     * @type {string}
     * @memberof EventMetaData
     */
    stat_type?: string;
    /**
     * The timing condition
     * @type {string}
     * @memberof EventMetaData
     */
    time_condition?: string;
    /**
     * The id of the transport
     * @type {string}
     * @memberof EventMetaData
     */
    transport_id?: string;
    /**
     * The name/id of a type
     * @type {string}
     * @memberof EventMetaData
     */
    type?: string;
    /**
     * The name/id of a unit type
     * @type {string}
     * @memberof EventMetaData
     */
    unit_type?: string;
    /**
     * The name of the upgrade
     * @type {string}
     * @memberof EventMetaData
     */
    upgrade_type?: string;
    /**
     * The action taken on a weapon (i.e. infrared-activated)
     * @type {string}
     * @memberof EventMetaData
     */
    weapon_action?: string;
    /**
     * The id of the weapon
     * @type {string}
     * @memberof EventMetaData
     */
    weapon_id?: string;
    /**
     * The type of the weapon
     * @type {string}
     * @memberof EventMetaData
     */
    weapon_type?: string;
    /**
     * The name/id of a weapon used in a kill or similar event
     * @type {string}
     * @memberof EventMetaData
     */
    weapon_used?: string;
    /**
     * The name of the zone
     * @type {string}
     * @memberof EventMetaData
     */
    zone_name?: string;
}
/**
 * 
 * @export
 * @interface EventPayload
 */
export interface EventPayload {
    /**
     * This is your user id. You can set this to whatever you like, either your real user id or an obfuscated user id. However you need to be consistent here. Events linked to this user id only track if challenges or battle passes are unlocked with the same user id.
     * @type {string}
     * @memberof EventPayload
     */
    user_id: string;
    /**
     * This is required if event_type is single and identifies a session. This can be anything used to group events together. For example this can be a level or a match id.
     * @type {string}
     * @memberof EventPayload
     */
    session_id: string;
    /**
     * This is the event type as a string. These have predefined event names for many games and applications. It’s wise to use those as this allows us to analyse data and help you balancing your application or game.
     * @type {string}
     * @memberof EventPayload
     */
    event_name: string;
    /**
     * This is either single or group. You can send multiple events in one request (group) or send events in sequence. Please note, that depending on your tier you might run into rate limits.
     * @type {string}
     * @memberof EventPayload
     */
    event_type?: string;
    /**
     * 
     * @type {EventMetaData}
     * @memberof EventPayload
     */
    meta_data?: EventMetaData;
}
/**
 * 
 * @export
 * @interface ForeignUserIdentifier
 */
export interface ForeignUserIdentifier {
    /**
     * Any string allowed, this is the foreign user identifier that has no relation in the SCILL database and the user is unkown to SCILL.
     * @type {string}
     * @memberof ForeignUserIdentifier
     */
    user_id: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message: string;
}
/**
 * 
 * @export
 * @interface SocketToken
 */
export interface SocketToken {
    /**
     * 
     * @type {string}
     * @memberof SocketToken
     */
    socket_token: string;
}
/**
 * 
 * @export
 * @interface UnknownChallengeError
 */
export interface UnknownChallengeError {
    /**
     * The error message
     * @type {string}
     * @memberof UnknownChallengeError
     */
    error?: string;
    /**
     * Machine readable error message
     * @type {string}
     * @memberof UnknownChallengeError
     */
    error_slug?: string;
    /**
     * HTTP status code of this error message'
     * @type {number}
     * @memberof UnknownChallengeError
     */
    status_code?: number;
}
/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get an access token for any user identifier signed with the API-Key
         * @param {ForeignUserIdentifier} body Foreign user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAccessToken(body: ForeignUserIdentifier, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling generateAccessToken.');
            }
            const localVarPath = `/api/v1/auth/access-token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ForeignUserIdentifier" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get an access token for any user identifier signed with the API-Key
         * @param {ForeignUserIdentifier} body Foreign user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAccessToken(body: ForeignUserIdentifier, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).generateAccessToken(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get an access token for any user identifier signed with the API-Key
         * @param {ForeignUserIdentifier} body Foreign user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAccessToken(body: ForeignUserIdentifier, options?: any) {
            return AuthApiFp(configuration).generateAccessToken(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Get an access token for any user identifier signed with the API-Key
     * @param {ForeignUserIdentifier} body Foreign user identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public generateAccessToken(body: ForeignUserIdentifier, options?: any) {
        return AuthApiFp(this.configuration).generateAccessToken(body, options)(this.fetch, this.basePath);
    }

}
/**
 * BattlePassesApi - fetch parameter creator
 * @export
 */
export const BattlePassesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Claim the reward of a battle pass level
         * @summary Claim the reward of a finished personal challenge
         * @param {BattlePassLevelId} body Provide the battle pass level id in this payload.
         * @param {string} appId The app id
         * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimBattlePassLevelReward(body: BattlePassLevelId, appId: string, bpid: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling claimBattlePassLevelReward.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling claimBattlePassLevelReward.');
            }
            // verify required parameter 'bpid' is not null or undefined
            if (bpid === null || bpid === undefined) {
                throw new RequiredError('bpid','Required parameter bpid was null or undefined when calling claimBattlePassLevelReward.');
            }
            const localVarPath = `/api/v1/battle-passes/{appId}/{bpid}/claim-level`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"bpid"}}`, encodeURIComponent(String(bpid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BattlePassLevelId" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get battle pass for the product with id
         * @summary Get battle passe by id
         * @param {string} appId The app id
         * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePass(appId: string, bpid: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getBattlePass.');
            }
            // verify required parameter 'bpid' is not null or undefined
            if (bpid === null || bpid === undefined) {
                throw new RequiredError('bpid','Required parameter bpid was null or undefined when calling getBattlePass.');
            }
            const localVarPath = `/api/v1/battle-passes/{appId}/{bpid}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"bpid"}}`, encodeURIComponent(String(bpid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get battle passes for the product
         * @summary Get battle passes
         * @param {string} appId The app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePasses(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getBattlePasses.');
            }
            const localVarPath = `/api/v1/battle-passes/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlock a battle pass level
         * @summary Unlock the level of a battle pass
         * @param {BattlePassLevelId} body Provide the battle pass level id in this payload
         * @param {string} appId The app id
         * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockBattlePassLevel(body: BattlePassLevelId, appId: string, bpid: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling unlockBattlePassLevel.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling unlockBattlePassLevel.');
            }
            // verify required parameter 'bpid' is not null or undefined
            if (bpid === null || bpid === undefined) {
                throw new RequiredError('bpid','Required parameter bpid was null or undefined when calling unlockBattlePassLevel.');
            }
            const localVarPath = `/api/v1/battle-passes/{appId}/{bpid}/unlock`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"bpid"}}`, encodeURIComponent(String(bpid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BattlePassLevelId" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BattlePassesApi - functional programming interface
 * @export
 */
export const BattlePassesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Claim the reward of a battle pass level
         * @summary Claim the reward of a finished personal challenge
         * @param {BattlePassLevelId} body Provide the battle pass level id in this payload.
         * @param {string} appId The app id
         * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimBattlePassLevelReward(body: BattlePassLevelId, appId: string, bpid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).claimBattlePassLevelReward(body, appId, bpid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get battle pass for the product with id
         * @summary Get battle passe by id
         * @param {string} appId The app id
         * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePass(appId: string, bpid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BattlePass> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).getBattlePass(appId, bpid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get battle passes for the product
         * @summary Get battle passes
         * @param {string} appId The app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePasses(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BattlePass>> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).getBattlePasses(appId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unlock a battle pass level
         * @summary Unlock the level of a battle pass
         * @param {BattlePassLevelId} body Provide the battle pass level id in this payload
         * @param {string} appId The app id
         * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockBattlePassLevel(body: BattlePassLevelId, appId: string, bpid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).unlockBattlePassLevel(body, appId, bpid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BattlePassesApi - factory interface
 * @export
 */
export const BattlePassesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Claim the reward of a battle pass level
         * @summary Claim the reward of a finished personal challenge
         * @param {BattlePassLevelId} body Provide the battle pass level id in this payload.
         * @param {string} appId The app id
         * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimBattlePassLevelReward(body: BattlePassLevelId, appId: string, bpid: string, options?: any) {
            return BattlePassesApiFp(configuration).claimBattlePassLevelReward(body, appId, bpid, options)(fetch, basePath);
        },
        /**
         * Get battle pass for the product with id
         * @summary Get battle passe by id
         * @param {string} appId The app id
         * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePass(appId: string, bpid: string, options?: any) {
            return BattlePassesApiFp(configuration).getBattlePass(appId, bpid, options)(fetch, basePath);
        },
        /**
         * Get battle passes for the product
         * @summary Get battle passes
         * @param {string} appId The app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePasses(appId: string, options?: any) {
            return BattlePassesApiFp(configuration).getBattlePasses(appId, options)(fetch, basePath);
        },
        /**
         * Unlock a battle pass level
         * @summary Unlock the level of a battle pass
         * @param {BattlePassLevelId} body Provide the battle pass level id in this payload
         * @param {string} appId The app id
         * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockBattlePassLevel(body: BattlePassLevelId, appId: string, bpid: string, options?: any) {
            return BattlePassesApiFp(configuration).unlockBattlePassLevel(body, appId, bpid, options)(fetch, basePath);
        },
    };
};

/**
 * BattlePassesApi - object-oriented interface
 * @export
 * @class BattlePassesApi
 * @extends {BaseAPI}
 */
export class BattlePassesApi extends BaseAPI {
    /**
     * Claim the reward of a battle pass level
     * @summary Claim the reward of a finished personal challenge
     * @param {BattlePassLevelId} body Provide the battle pass level id in this payload.
     * @param {string} appId The app id
     * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public claimBattlePassLevelReward(body: BattlePassLevelId, appId: string, bpid: string, options?: any) {
        return BattlePassesApiFp(this.configuration).claimBattlePassLevelReward(body, appId, bpid, options)(this.fetch, this.basePath);
    }

    /**
     * Get battle pass for the product with id
     * @summary Get battle passe by id
     * @param {string} appId The app id
     * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public getBattlePass(appId: string, bpid: string, options?: any) {
        return BattlePassesApiFp(this.configuration).getBattlePass(appId, bpid, options)(this.fetch, this.basePath);
    }

    /**
     * Get battle passes for the product
     * @summary Get battle passes
     * @param {string} appId The app id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public getBattlePasses(appId: string, options?: any) {
        return BattlePassesApiFp(this.configuration).getBattlePasses(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Unlock a battle pass level
     * @summary Unlock the level of a battle pass
     * @param {BattlePassLevelId} body Provide the battle pass level id in this payload
     * @param {string} appId The app id
     * @param {string} bpid The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public unlockBattlePassLevel(body: BattlePassLevelId, appId: string, bpid: string, options?: any) {
        return BattlePassesApiFp(this.configuration).unlockBattlePassLevel(body, appId, bpid, options)(this.fetch, this.basePath);
    }

}
/**
 * ChallengesApi - fetch parameter creator
 * @export
 */
export const ChallengesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a personal challenge by product id and user challenge id
         * @summary Activate a personal challenges
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePersonalChallenge(appId: string, cid: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling activatePersonalChallenge.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling activatePersonalChallenge.');
            }
            const localVarPath = `/api/v1/challenges/personal/activate/{appId}/{cid}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active personal challenge by product id and user challenge id
         * @summary Cancel an active personal challenges
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPersonalChallenge(appId: string, cid: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling cancelPersonalChallenge.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling cancelPersonalChallenge.');
            }
            const localVarPath = `/api/v1/challenges/personal/cancel/{appId}/{cid}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Claim the reward of a finished personal challenge by product id and user challenge id
         * @summary Claim the reward of a finished personal challenge
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPersonalChallengeReward(appId: string, cid: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling claimPersonalChallengeReward.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling claimPersonalChallengeReward.');
            }
            const localVarPath = `/api/v1/challenges/personal/claim/{appId}/{cid}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an access token for the Websockets server notifying of updates in real time
         * @summary Get an access token for the Websockets server notifying of updates in real time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWebsocketAccessToken(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/challenges/web-socket/generate-token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get active personal challenges organized in categories
         * @summary Get active personal challenges
         * @param {string} appId The app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePersonalChallenges(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getActivePersonalChallenges.');
            }
            const localVarPath = `/api/v1/challenges/personal/get-in-progress-challenges/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get personal challenges organized in categories
         * @summary Get personal challenges
         * @param {string} appId The app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalChallenges(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getPersonalChallenges.');
            }
            const localVarPath = `/api/v1/challenges/personal/get/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlock a personal challenge by product id and challenge id
         * @summary Unlock a personal challenges
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockPersonalChallenge(appId: string, cid: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling unlockPersonalChallenge.');
            }
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling unlockPersonalChallenge.');
            }
            const localVarPath = `/api/v1/challenges/personal/unlock/{appId}/{cid}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChallengesApi - functional programming interface
 * @export
 */
export const ChallengesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Activate a personal challenge by product id and user challenge id
         * @summary Activate a personal challenges
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePersonalChallenge(appId: string, cid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).activatePersonalChallenge(appId, cid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancel an active personal challenge by product id and user challenge id
         * @summary Cancel an active personal challenges
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPersonalChallenge(appId: string, cid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).cancelPersonalChallenge(appId, cid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Claim the reward of a finished personal challenge by product id and user challenge id
         * @summary Claim the reward of a finished personal challenge
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPersonalChallengeReward(appId: string, cid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).claimPersonalChallengeReward(appId, cid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an access token for the Websockets server notifying of updates in real time
         * @summary Get an access token for the Websockets server notifying of updates in real time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWebsocketAccessToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SocketToken> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).generateWebsocketAccessToken(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get active personal challenges organized in categories
         * @summary Get active personal challenges
         * @param {string} appId The app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePersonalChallenges(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChallengeCategory>> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).getActivePersonalChallenges(appId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get personal challenges organized in categories
         * @summary Get personal challenges
         * @param {string} appId The app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalChallenges(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChallengeCategory>> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).getPersonalChallenges(appId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unlock a personal challenge by product id and challenge id
         * @summary Unlock a personal challenges
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockPersonalChallenge(appId: string, cid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).unlockPersonalChallenge(appId, cid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChallengesApi - factory interface
 * @export
 */
export const ChallengesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Activate a personal challenge by product id and user challenge id
         * @summary Activate a personal challenges
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePersonalChallenge(appId: string, cid: string, options?: any) {
            return ChallengesApiFp(configuration).activatePersonalChallenge(appId, cid, options)(fetch, basePath);
        },
        /**
         * Cancel an active personal challenge by product id and user challenge id
         * @summary Cancel an active personal challenges
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPersonalChallenge(appId: string, cid: string, options?: any) {
            return ChallengesApiFp(configuration).cancelPersonalChallenge(appId, cid, options)(fetch, basePath);
        },
        /**
         * Claim the reward of a finished personal challenge by product id and user challenge id
         * @summary Claim the reward of a finished personal challenge
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPersonalChallengeReward(appId: string, cid: string, options?: any) {
            return ChallengesApiFp(configuration).claimPersonalChallengeReward(appId, cid, options)(fetch, basePath);
        },
        /**
         * Get an access token for the Websockets server notifying of updates in real time
         * @summary Get an access token for the Websockets server notifying of updates in real time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWebsocketAccessToken(options?: any) {
            return ChallengesApiFp(configuration).generateWebsocketAccessToken(options)(fetch, basePath);
        },
        /**
         * Get active personal challenges organized in categories
         * @summary Get active personal challenges
         * @param {string} appId The app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePersonalChallenges(appId: string, options?: any) {
            return ChallengesApiFp(configuration).getActivePersonalChallenges(appId, options)(fetch, basePath);
        },
        /**
         * Get personal challenges organized in categories
         * @summary Get personal challenges
         * @param {string} appId The app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalChallenges(appId: string, options?: any) {
            return ChallengesApiFp(configuration).getPersonalChallenges(appId, options)(fetch, basePath);
        },
        /**
         * Unlock a personal challenge by product id and challenge id
         * @summary Unlock a personal challenges
         * @param {string} appId The app id
         * @param {string} cid The challenge id (see challenge_id of Challenge object)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockPersonalChallenge(appId: string, cid: string, options?: any) {
            return ChallengesApiFp(configuration).unlockPersonalChallenge(appId, cid, options)(fetch, basePath);
        },
    };
};

/**
 * ChallengesApi - object-oriented interface
 * @export
 * @class ChallengesApi
 * @extends {BaseAPI}
 */
export class ChallengesApi extends BaseAPI {
    /**
     * Activate a personal challenge by product id and user challenge id
     * @summary Activate a personal challenges
     * @param {string} appId The app id
     * @param {string} cid The challenge id (see challenge_id of Challenge object)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public activatePersonalChallenge(appId: string, cid: string, options?: any) {
        return ChallengesApiFp(this.configuration).activatePersonalChallenge(appId, cid, options)(this.fetch, this.basePath);
    }

    /**
     * Cancel an active personal challenge by product id and user challenge id
     * @summary Cancel an active personal challenges
     * @param {string} appId The app id
     * @param {string} cid The challenge id (see challenge_id of Challenge object)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public cancelPersonalChallenge(appId: string, cid: string, options?: any) {
        return ChallengesApiFp(this.configuration).cancelPersonalChallenge(appId, cid, options)(this.fetch, this.basePath);
    }

    /**
     * Claim the reward of a finished personal challenge by product id and user challenge id
     * @summary Claim the reward of a finished personal challenge
     * @param {string} appId The app id
     * @param {string} cid The challenge id (see challenge_id of Challenge object)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public claimPersonalChallengeReward(appId: string, cid: string, options?: any) {
        return ChallengesApiFp(this.configuration).claimPersonalChallengeReward(appId, cid, options)(this.fetch, this.basePath);
    }

    /**
     * Get an access token for the Websockets server notifying of updates in real time
     * @summary Get an access token for the Websockets server notifying of updates in real time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public generateWebsocketAccessToken(options?: any) {
        return ChallengesApiFp(this.configuration).generateWebsocketAccessToken(options)(this.fetch, this.basePath);
    }

    /**
     * Get active personal challenges organized in categories
     * @summary Get active personal challenges
     * @param {string} appId The app id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public getActivePersonalChallenges(appId: string, options?: any) {
        return ChallengesApiFp(this.configuration).getActivePersonalChallenges(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Get personal challenges organized in categories
     * @summary Get personal challenges
     * @param {string} appId The app id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public getPersonalChallenges(appId: string, options?: any) {
        return ChallengesApiFp(this.configuration).getPersonalChallenges(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Unlock a personal challenge by product id and challenge id
     * @summary Unlock a personal challenges
     * @param {string} appId The app id
     * @param {string} cid The challenge id (see challenge_id of Challenge object)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public unlockPersonalChallenge(appId: string, cid: string, options?: any) {
        return ChallengesApiFp(this.configuration).unlockPersonalChallenge(appId, cid, options)(this.fetch, this.basePath);
    }

}
/**
 * EventsApi - fetch parameter creator
 * @export
 */
export const EventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Post an event to the SCILL backend
         * @summary Post an event
         * @param {EventPayload} body Event payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEvent(body: EventPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendEvent.');
            }
            const localVarPath = `/api/v1/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [""])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Post an event to the SCILL backend
         * @summary Post an event
         * @param {EventPayload} body Event payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEvent(body: EventPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).sendEvent(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Post an event to the SCILL backend
         * @summary Post an event
         * @param {EventPayload} body Event payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEvent(body: EventPayload, options?: any) {
            return EventsApiFp(configuration).sendEvent(body, options)(fetch, basePath);
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Post an event to the SCILL backend
     * @summary Post an event
     * @param {EventPayload} body Event payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public sendEvent(body: EventPayload, options?: any) {
        return EventsApiFp(this.configuration).sendEvent(body, options)(this.fetch, this.basePath);
    }

}
