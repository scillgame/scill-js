/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * SCILL API
 * SCILL gives you the tools to activate, retain and grow your user base in your app or game by bringing you features well known in the gaming industry: Gamification. We take care of the services and technology involved so you can focus on your game and content.
 *
 * OpenAPI spec version: 1.2.0
 * Contact: support@scillgame.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/4Players-GmbH/scill-gaas/1.2.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * As SCILL does not know anything about the users an access token is required to handle authentication. Requesting an access token in the backend returns this object that contains the token which needs to be set as the Authentication Bearer in subsequent requests to the SCILL backend.
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    token?: string;
}
/**
 * Standard response for actions like update or delete. If anything went fine, you'll receive a HTTP code of 200 and a OK message.
 * @export
 * @interface ActionResponse
 */
export interface ActionResponse {
    /**
     * HTTP status code
     * @type {number}
     * @memberof ActionResponse
     */
    status: number;
    /**
     * 
     * @type {string}
     * @memberof ActionResponse
     */
    message: string;
    /**
     * 
     * @type {Challenge}
     * @memberof ActionResponse
     */
    challenge?: Challenge;
}
/**
 * A Battle Pass is a structured layer above challenges and handles the lifecycle of challenges based on a level system. Users need to fullfil challenges to unlock the next level. Each level can have a reward that you can specify in the BattlePassLevel structure. Battle Passes need to be unlocked before they start tracking progress.
 * @export
 * @interface BattlePass
 */
export interface BattlePass {
    /**
     * The unique id of this battle pass.
     * @type {string}
     * @memberof BattlePass
     */
    battle_pass_id?: string;
    /**
     * The unique id of the app
     * @type {string}
     * @memberof BattlePass
     */
    app_id?: string;
    /**
     * The name of the battle bass. You can set that in the Admin Panel. The language is set with the query parameter language. See documentation for more info on that.
     * @type {string}
     * @memberof BattlePass
     */
    battle_pass_name?: string;
    /**
     * The description of the battle bass. You can set that in the Admin Panel and it can also be HTML. The language is set with the query parameter language. See documentation for more info on that.
     * @type {string}
     * @memberof BattlePass
     */
    battle_pass_description?: string;
    /**
     * A short description of the battle bass. You can set that in the Admin Panel and it can also be HTML. The language is set with the query parameter language. See documentation for more info on that.
     * @type {string}
     * @memberof BattlePass
     */
    battle_pass_short_description?: string;
    /**
     * Use this to provide some terms and conditions following along this battle passes purchase.
     * @type {string}
     * @memberof BattlePass
     */
    battle_pass_disclaimer?: string;
    /**
     * The priority of the battle pass. I.e. if multiple are available you can use this field to sort them.
     * @type {number}
     * @memberof BattlePass
     */
    battle_pass_priority?: number;
    /**
     * If you want to sell Battle Passes you can use this field to trigger in-app purchase products within your mobile app. You can set this value in the Admin Panel. This one is for iOS.
     * @type {string}
     * @memberof BattlePass
     */
    package_sku_ios?: string;
    /**
     * If you want to sell Battle Passes you can use this field to trigger in-app purchase products within your mobile app. You can set this value in the Admin Panel. Use this to set the package string for Android.
     * @type {string}
     * @memberof BattlePass
     */
    package_sku_android?: string;
    /**
     * The xs sized image name or url. You can determine the best size distribution yourself and depends on your application or UI
     * @type {string}
     * @memberof BattlePass
     */
    image_xs?: string;
    /**
     * The s sized image name or url. You can determine the best size distribution yourself and depends on your application or UI
     * @type {string}
     * @memberof BattlePass
     */
    image_s?: string;
    /**
     * The m sized image name or url. You can determine the best size distribution yourself and depends on your application or UI
     * @type {string}
     * @memberof BattlePass
     */
    image_m?: string;
    /**
     * The l sized image name or url. You can determine the best size distribution yourself and depends on your application or UI
     * @type {string}
     * @memberof BattlePass
     */
    image_l?: string;
    /**
     * The xl sized image name or url. You can determine the best size distribution yourself and depends on your application or UI
     * @type {string}
     * @memberof BattlePass
     */
    image_xl?: string;
    /**
     * The date (in iso format) when the Battle Pass starts. Tracking begins once this date is passed.
     * @type {string}
     * @memberof BattlePass
     */
    start_date?: string;
    /**
     * The date (in iso format) when the Battle Pass ends. Tracking stops once the end is reached and users will not be able to progress further than what they have achieved up to that point.
     * @type {string}
     * @memberof BattlePass
     */
    end_date?: string;
    /**
     * If the Battle Pass costs “money” you may want to route the user to a web site/page, where they can learn more about this battle pass. You can also use this field to route the user inside your application by providing a path or whatever works for you.
     * @type {string}
     * @memberof BattlePass
     */
    read_more_link?: string;
    /**
     * Indicates if one level after the other must be activated or if users can activate whichever level they want. Typically battle passes are unlocked level by level, but if battle passes are used for other applications (like user referal programs) it can be useful to set this to false.
     * @type {boolean}
     * @memberof BattlePass
     */
    is_unlocked_incrementally?: boolean;
    /**
     * Indicated if this battle pass is active.
     * @type {boolean}
     * @memberof BattlePass
     */
    is_active?: boolean;
    /**
     * The date in iso format when the user unlocked this Battle Pass.
     * @type {string}
     * @memberof BattlePass
     */
    unlocked_at?: string;
    /**
     * Indicates that this Battle Pass can be purchased via in-app purchase. This can be set in the Admin Panel.
     * @type {boolean}
     * @memberof BattlePass
     */
    can_purchase_with_money?: boolean;
    /**
     * Indicates that this Battle Pass can be purchased with SCILL Coins. This can be set in the Admin Panel.
     * @type {boolean}
     * @memberof BattlePass
     */
    can_purchase_with_coins?: boolean;
}
/**
 * This payload is sent in Webhooks and notifications as part of the battlepass-challenge-changed notification. The idea is to provide enough information to quickly update UI or implementing backend logic. We provide both the state of the object before it changed, and after that. This allows you to react in many different ways.
 * @export
 * @interface BattlePassChallengeChangedPayload
 */
export interface BattlePassChallengeChangedPayload {
    /**
     * The type of the notification. If you receive this payload, it's most likely battlepass-challenge-changed
     * @type {string}
     * @memberof BattlePassChallengeChangedPayload
     */
    webhook_type?: string;
    /**
     * 
     * @type {BattlePassChallengeState}
     * @memberof BattlePassChallengeChangedPayload
     */
    old_battle_pass_challenge?: BattlePassChallengeState;
    /**
     * 
     * @type {BattlePassChallengeState}
     * @memberof BattlePassChallengeChangedPayload
     */
    new_battle_pass_challenge?: BattlePassChallengeState;
}
/**
 * This object stores information about a battle pass challenge state. It is designed to update challenges loaded previously with the getBattlePassLevels API. Indices allow you to quickly update locally stored Challenge objects without iterating or reloading data.
 * @export
 * @interface BattlePassChallengeState
 */
export interface BattlePassChallengeState {
    /**
     * The unique id of the app
     * @type {string}
     * @memberof BattlePassChallengeState
     */
    app_id?: string;
    /**
     * The unique id of this battle pass.
     * @type {string}
     * @memberof BattlePassChallengeState
     */
    battle_pass_id?: string;
    /**
     * Unique id of this BattlePassLevel object.
     * @type {string}
     * @memberof BattlePassChallengeState
     */
    level_id?: string;
    /**
     * This is your user id. You can set this to whatever you like, either your real user id or an obfuscated user id. However you need to be consistent here. Events linked to this user id only track if challenges or battle passes are unlocked with the same user id.
     * @type {string}
     * @memberof BattlePassChallengeState
     */
    user_id?: string;
    /**
     * Typical usage pattern is to load battle pass levels with getBattlePassLevels operation and store them for rendering. Using this value you can quickly identify the index of the level that changed.
     * @type {number}
     * @memberof BattlePassChallengeState
     */
    level_position_index?: number;
    /**
     * The unique id of this challenge. Every challenge is linked to a product.
     * @type {string}
     * @memberof BattlePassChallengeState
     */
    challenge_id?: string;
    /**
     * Same as level_position_index. Use this index to identify the challenge that changed within the levels challenges array. Typical usage pattern is to update the previously stored score and type.
     * @type {number}
     * @memberof BattlePassChallengeState
     */
    challenge_position_index?: number;
    /**
     * Indicates how many “tasks” must be completed or done to complete this challenge.
     * @type {number}
     * @memberof BattlePassChallengeState
     */
    challenge_goal?: number;
    /**
     * Indicates how many tasks the user already has completed. Use this in combination with challenge_goal to render a nice progress bar.
     * @type {number}
     * @memberof BattlePassChallengeState
     */
    user_challenge_current_score?: number;
    /**
     * Indicates the status of the challenge. This can be one of the following unlock: Challenge does not track anything. in-progress: Challenge is active and tracking. overtime: User did not manage to finish the challenge in time. unclaimed: The challenge has been completed but the reward has not yet been claimed. finished: The challenge has been successfully be completed and the reward has been claimed
     * @type {string}
     * @memberof BattlePassChallengeState
     */
    type?: string;
}
/**
 * Battle Passes are grouped into levels that contain challenges that must be achieved to unlock the next level. Only challenges for the current level are tracking progress.
 * @export
 * @interface BattlePassLevel
 */
export interface BattlePassLevel {
    /**
     * Unique id of this BattlePassLevel object.
     * @type {string}
     * @memberof BattlePassLevel
     */
    level_id?: string;
    /**
     * The app id
     * @type {string}
     * @memberof BattlePassLevel
     */
    app_id?: string;
    /**
     * The id of the battle pass this level belongs to
     * @type {string}
     * @memberof BattlePassLevel
     */
    battle_pass_id?: string;
    /**
     * In the Admin Panel you can set different types of rewards. You can also set an identifier of an in-game-item or anything you like. Use this to include the reward into your own business logic.
     * @type {string}
     * @memberof BattlePassLevel
     */
    reward_amount?: string;
    /**
     * There are different types of rewards available. Possible values are Coins, Voucher, Money and Experience. This is deprecated in favor of level_reward_type which uses a slug instead of a human readable expression
     * @type {string}
     * @memberof BattlePassLevel
     */
    reward_type_name?: string;
    /**
     * The reward type in a machine readable slug. Available values are nothing, coin, experience, item
     * @type {string}
     * @memberof BattlePassLevel
     */
    level_reward_type?: string;
    /**
     * Indicates if this level is completed, i.e. all challenges have been completed.
     * @type {boolean}
     * @memberof BattlePassLevel
     */
    level_completed?: boolean;
    /**
     * Indicates the position of the level.
     * @type {number}
     * @memberof BattlePassLevel
     */
    level_priority?: number;
    /**
     * Indicates if this level has already be claimed.
     * @type {boolean}
     * @memberof BattlePassLevel
     */
    reward_claimed?: boolean;
    /**
     * The date when this level has been activated or null if it's not activated.
     * @type {string}
     * @memberof BattlePassLevel
     */
    activated_at?: string;
    /**
     * An array of BattlePassLevelChallenge objects. Please note, not all values are available from the challenge object, as battle passes handle the lifecycle of challenges.
     * @type {Array<BattlePassLevelChallenge>}
     * @memberof BattlePassLevel
     */
    challenges?: Array<BattlePassLevelChallenge>;
}
/**
 * Each level in battle passes contains one or more challenges that need to be fullfilled to unlock the next level. This structure holds challenge information and is based on the Challenge structure. However, as Battle Passes manage the lifecycle of challenges, this data structure is a bit simpler. The same principles apply mostly as for the personal challenges, i.e. you can share the exact same UI to render personal challenges and battle pass challenges.
 * @export
 * @interface BattlePassLevelChallenge
 */
export interface BattlePassLevelChallenge {
    /**
     * The unique id of this challenge. Every challenge is linked to a product.
     * @type {string}
     * @memberof BattlePassLevelChallenge
     */
    challenge_id?: string;
    /**
     * The name of the challenge in the language set by the language parameter.
     * @type {string}
     * @memberof BattlePassLevelChallenge
     */
    challenge_name?: string;
    /**
     * Indicates how many “tasks” must be completed or done to complete this challenge.
     * @type {number}
     * @memberof BattlePassLevelChallenge
     */
    challenge_goal?: number;
    /**
     * With this you can set the way how the SCILL system approaches the challenges state. 0 means, that the counter of the challenge must be brought above the goal. If this is 1, then the counter must be kept below the goal. This is often useful for challenges that include times, like: Manage the level in under 50 seconds.
     * @type {number}
     * @memberof BattlePassLevelChallenge
     */
    challenge_goal_condition?: number;
    /**
     * Indicates how many tasks the user already has completed. Use this in combination with challenge_goal to render a nice progress bar.
     * @type {number}
     * @memberof BattlePassLevelChallenge
     */
    user_challenge_current_score?: number;
    /**
     * If you have experience, player rankings whatever, you can use this field to set the gain in that when this challenge is rewarded.
     * @type {number}
     * @memberof BattlePassLevelChallenge
     */
    challenge_xp?: number;
    /**
     * In the admin panel you can set a string representing an image. This can be a URL, but it can also be an image or texture that you have in your games asset database.
     * @type {string}
     * @memberof BattlePassLevelChallenge
     */
    challenge_icon?: string;
    /**
     * This is the HD variant of the challenge icon image. If you have a game, that runs on multiple platforms that could come in handy. Otherwise just leave blank.
     * @type {string}
     * @memberof BattlePassLevelChallenge
     */
    challenge_icon_hd?: string;
    /**
     * Indicates the status of the challenge. This can be one of the following unlock: Challenge does not track anything. in-progress: Challenge is active and tracking. overtime: User did not manage to finish the challenge in time. unclaimed: The challenge has been completed but the reward has not yet been claimed. finished: The challenge has been successfully be completed and the reward has been claimed
     * @type {string}
     * @memberof BattlePassLevelChallenge
     */
    type?: string;
}
/**
 * Payload sent via Webhook or realtime notifications whenever a usrs level reward has been claimed. Use this payload to unlock the item for the specified user.
 * @export
 * @interface BattlePassLevelClaimedPayload
 */
export interface BattlePassLevelClaimedPayload {
    /**
     * The type of the notification. If you receive this payload, it's most likely battlepass-level-reward-claimed
     * @type {string}
     * @memberof BattlePassLevelClaimedPayload
     */
    webhook_type?: string;
    /**
     * 
     * @type {BattlePassLevelReward}
     * @memberof BattlePassLevelClaimedPayload
     */
    battle_pass_level_reward_claimed?: BattlePassLevelReward;
}
/**
 * Used in previous versions of the battle pass system to provide the level_id via payload. We changed routes in newer versions to have level id in the path.
 * @export
 * @interface BattlePassLevelId
 */
export interface BattlePassLevelId {
    /**
     * The level id, i.e. battle_pass_level_id of the BattlePassLevel object
     * @type {string}
     * @memberof BattlePassLevelId
     */
    battle_pass_level_id: string;
}
/**
 * This objects holds information about a battle pass reward
 * @export
 * @interface BattlePassLevelReward
 */
export interface BattlePassLevelReward {
    /**
     * The unique id of the app
     * @type {string}
     * @memberof BattlePassLevelReward
     */
    app_id?: string;
    /**
     * The unique id of this battle pass.
     * @type {string}
     * @memberof BattlePassLevelReward
     */
    battle_pass_id?: string;
    /**
     * Unique id of this BattlePassLevel object.
     * @type {string}
     * @memberof BattlePassLevelReward
     */
    level_id?: string;
    /**
     * This is your user id. You can set this to whatever you like, either your real user id or an obfuscated user id. However you need to be consistent here. Events linked to this user id only track if challenges or battle passes are unlocked with the same user id.
     * @type {string}
     * @memberof BattlePassLevelReward
     */
    user_id?: string;
    /**
     * Typical usage pattern is to load battle pass levels with getBattlePassLevels operation and store them for rendering. Using this value you can quickly identify the index of the level that changed.
     * @type {number}
     * @memberof BattlePassLevelReward
     */
    level_position_index?: number;
    /**
     * In the Admin Panel you can set different types of rewards. You can also set an identifier of an in-game-item or anything you like. Use this to include the reward into your own business logic.
     * @type {string}
     * @memberof BattlePassLevelReward
     */
    reward_amount?: string;
    /**
     * There are different types of rewards available. Possible values are Coins, Voucher, Money and Experience.
     * @type {string}
     * @memberof BattlePassLevelReward
     */
    reward_type_name?: string;
}
/**
 * This object holds some basic info about lifetime of a battle pass and is used in expired notifications.
 * @export
 * @interface BattlePassState
 */
export interface BattlePassState {
    /**
     * The unique id of this battle pass.
     * @type {string}
     * @memberof BattlePassState
     */
    battle_pass_id?: string;
    /**
     * The unique id of the app
     * @type {string}
     * @memberof BattlePassState
     */
    app_id?: string;
    /**
     * The priority of the battle pass. I.e. if multiple are available you can use this field to sort them.
     * @type {number}
     * @memberof BattlePassState
     */
    battle_pass_priority?: number;
    /**
     * The date (in iso format) when the Battle Pass starts. Tracking begins once this date is passed.
     * @type {string}
     * @memberof BattlePassState
     */
    start_date?: string;
    /**
     * The date (in iso format) when the Battle Pass ends. Tracking stops once the end is reached and users will not be able to progress further than what they have achieved up to that point.
     * @type {string}
     * @memberof BattlePassState
     */
    end_date?: string;
    /**
     * Indicated if this battle pass is active.
     * @type {boolean}
     * @memberof BattlePassState
     */
    is_active?: boolean;
}
/**
 * 
 * @export
 * @interface BattlePassTranslation
 */
export interface BattlePassTranslation {
    /**
     * The id of the language
     * @type {string}
     * @memberof BattlePassTranslation
     */
    language_id?: string;
    /**
     * The name of the Battle Pass in the local language set in the request (see Setting Language). In the admin panel you can either create HTML content or plain text.
     * @type {string}
     * @memberof BattlePassTranslation
     */
    name?: string;
    /**
     * The description of the Battle Pass in the local language set in the request (see Setting Language). In the admin panel you can either create HTML content or plain text.
     * @type {string}
     * @memberof BattlePassTranslation
     */
    description?: string;
    /**
     * A short description in the local language you can use to teaser battle passes or implement “expand for more” functionality.
     * @type {string}
     * @memberof BattlePassTranslation
     */
    short_description?: string;
    /**
     * Use this to provide some terms and conditions following along this battle passes purchase.
     * @type {string}
     * @memberof BattlePassTranslation
     */
    disclaimer?: string;
}
/**
 * 
 * @export
 * @interface BattlePassUnlockInfo
 */
export interface BattlePassUnlockInfo {
    /**
     * The id of this battle pass purchase
     * @type {string}
     * @memberof BattlePassUnlockInfo
     */
    purchase_id?: string;
    /**
     * The battle pass id
     * @type {string}
     * @memberof BattlePassUnlockInfo
     */
    battle_pass_id?: string;
    /**
     * The user id of this battle pass purchase
     * @type {string}
     * @memberof BattlePassUnlockInfo
     */
    user_id?: string;
    /**
     * The price paid for this battle pass
     * @type {number}
     * @memberof BattlePassUnlockInfo
     */
    purchase_price?: number;
    /**
     * The currency used to purchase this battle pass
     * @type {string}
     * @memberof BattlePassUnlockInfo
     */
    purchase_currency?: string;
    /**
     * The date this battle pass has been purchased
     * @type {string}
     * @memberof BattlePassUnlockInfo
     */
    purchased_at?: string;
    /**
     * Indicates if this battle pass has been completed
     * @type {boolean}
     * @memberof BattlePassUnlockInfo
     */
    battle_pass_completed?: boolean;
}
/**
 * Unlocking a battle pass requires some info to be sent so we can validate everything is ok
 * @export
 * @interface BattlePassUnlockPayload
 */
export interface BattlePassUnlockPayload {
    /**
     * The purchase price. Set to 0 if this was free. The idea behind this is to provide information via an Admin Panel on average purchase price and to also allow showing users purchase info in their user account.
     * @type {number}
     * @memberof BattlePassUnlockPayload
     */
    purchase_price: number;
    /**
     * The currency (EUR, USD, etc) of the purchase price
     * @type {string}
     * @memberof BattlePassUnlockPayload
     */
    purchase_currency: string;
}
/**
 * The challenge object holds all information about a users challenge. It contains information like the duration, the type, progress states like counter and the goal and various other info.
 * @export
 * @interface Challenge
 */
export interface Challenge {
    /**
     * The unique id of this challenge. Every challenge is linked to a product.
     * @type {string}
     * @memberof Challenge
     */
    challenge_id?: string;
    /**
     * The name of the challenge in the language set by the language parameter.
     * @type {string}
     * @memberof Challenge
     */
    challenge_name?: string;
    /**
     * An optional multi-language description that can be set in the Admin Panel. Used to describe exactly what the user has to do.
     * @type {string}
     * @memberof Challenge
     */
    challenge_description?: string;
    /**
     * The duration of the challenge in seconds. Challenges auto lock after time-out and need to be unlocked again.
     * @type {number}
     * @memberof Challenge
     */
    challenge_duration_time?: number;
    /**
     * The date this challenge should start. Use that field to create challenges that start in the future.
     * @type {string}
     * @memberof Challenge
     */
    live_date?: string;
    /**
     * Indicates how many “tasks” must be completed or done to complete this challenge.
     * @type {number}
     * @memberof Challenge
     */
    challenge_goal?: number;
    /**
     * Indicates how many tasks the user already has completed. Use this in combination with challenge_goal to render a nice progress bar.
     * @type {number}
     * @memberof Challenge
     */
    user_challenge_current_score?: number;
    /**
     * In the admin panel you can set a string representing an image. This can be a URL, but it can also be an image or texture that you have in your games asset database.
     * @type {string}
     * @memberof Challenge
     */
    challenge_icon?: string;
    /**
     * This is the HD variant of the challenge icon image. If you have a game, that runs on multiple platforms that could come in handy. Otherwise just leave blank.
     * @type {string}
     * @memberof Challenge
     */
    challenge_icon_hd?: string;
    /**
     * If you purchase the challenge, you can set a price.
     * @type {number}
     * @memberof Challenge
     */
    challenge_price?: number;
    /**
     * Set a reward for this challenge. This is a string value that you can map to anything in your code. Use in combination with challenge_reward_type.
     * @type {string}
     * @memberof Challenge
     */
    challenge_reward?: string;
    /**
     * The reward type can be set to various different settings. Use it to implement different reward types on your side and use challenge_reward to set the value or amount of this reward.
     * @type {string}
     * @memberof Challenge
     */
    challenge_reward_type?: string;
    /**
     * With this you can set the way how the SCILL system approaches the challenges state. 0 means, that the counter of the challenge must be brought above the goal. If this is 1, then the counter must be kept below the goal. This is often useful for challenges that include times, like: Manage the level in under 50 seconds.
     * @type {number}
     * @memberof Challenge
     */
    challenge_goal_condition?: number;
    /**
     * If you have experience, player rankings whatever, you can use this field to set the gain in that when this challenge is rewarded.
     * @type {number}
     * @memberof Challenge
     */
    challenge_xp?: number;
    /**
     * If this challenge can be only activated once per user this will be false. Otherwise this challenge will always be added to list of available challenges (see personal or alliance challenges).
     * @type {boolean}
     * @memberof Challenge
     */
    repeatable?: boolean;
    /**
     * Indicates the status of the challenge. This can be one of the following unlock: Challenge does not track anything. in-progress: Challenge is active and tracking. overtime: User did not manage to finish the challenge in time. unclaimed: The challenge has been completed but the reward has not yet been claimed. finished: The challenge has been successfully be completed and the reward has been claimed
     * @type {string}
     * @memberof Challenge
     */
    type?: string;
    /**
     * Indicates if the challenges lifecycle is handled automatically by the SCILL backend. Use this flag to decide when to show action buttons for unlocking, activating, claiming or canceling challenges. Hide the buttons if this flag is true, and let the user manage challenges manually if this flag is false.
     * @type {boolean}
     * @memberof Challenge
     */
    challenge_auto_activated?: boolean;
    /**
     * If the challenge reward has been claimed this is true otherwise its false.
     * @type {boolean}
     * @memberof Challenge
     */
    is_claimed?: boolean;
    /**
     * This is the timestamp the challenge has been unlocked.
     * @type {string}
     * @memberof Challenge
     */
    user_challenge_unlocked_at?: string;
    /**
     * This is the timestamp the challenge has been activated.
     * @type {string}
     * @memberof Challenge
     */
    user_challenge_activated_at?: string;
    /**
     * Indicates if this challenge has been claimed.
     * @type {boolean}
     * @memberof Challenge
     */
    user_challenge_is_claimed?: boolean;
    /**
     * Gives indication in what state the challenge is.
     * @type {number}
     * @memberof Challenge
     */
    user_challenge_status?: number;
}
/**
 * Challenges are grouped into categories. You can exclude or include categories in queries. Per default all categories will be returned.
 * @export
 * @interface ChallengeCategory
 */
export interface ChallengeCategory {
    /**
     * Indicates if this is the daily category, bringing up new challenges every day for the user to tackle.
     * @type {boolean}
     * @memberof ChallengeCategory
     */
    is_daily_category?: boolean;
    /**
     * In the admin panel you set the order of the categories. This is the position index and indicates the position within the categories array.
     * @type {number}
     * @memberof ChallengeCategory
     */
    category_position?: number;
    /**
     * A short name without special chars to make it easier to refer to a specific category (in code) that is language and id agnostic.
     * @type {string}
     * @memberof ChallengeCategory
     */
    category_slug?: string;
    /**
     * The name of the category in the local language set as the query parameter.
     * @type {string}
     * @memberof ChallengeCategory
     */
    category_name?: string;
    /**
     * Indicates how many “tasks” must be completed or done to complete this challenge.
     * @type {string}
     * @memberof ChallengeCategory
     */
    category_id?: string;
    /**
     * An array of Challenge objects.
     * @type {Array<Challenge>}
     * @memberof ChallengeCategory
     */
    challenges?: Array<Challenge>;
}
/**
 * The payload sent to the users webhook.
 * @export
 * @interface ChallengeWebhookPayload
 */
export interface ChallengeWebhookPayload {
    /**
     * The type of the webhook. Depending on the module, there are different webhook types indicating different events. Check the reference documentation to see all types.
     * @type {string}
     * @memberof ChallengeWebhookPayload
     */
    webhook_type?: string;
    /**
     * The index of the category this challenge is linked to. When you request personal challenges, you get an array of categories which contain an array of challenges in their challenges property. This value indicates in which category this challenge can be found. Speeds up updating UI as you don't need to iterate through all catagories and challenges to find the challenge.
     * @type {number}
     * @memberof ChallengeWebhookPayload
     */
    category_position?: number;
    /**
     * The access token for the user of that challenge. You can use that user_token to directly send another event and therefore to chain different SCILL pieces together. For example you can send another event driving another challenge or battle pass whenever a user has completed a challenge.
     * @type {string}
     * @memberof ChallengeWebhookPayload
     */
    user_token?: string;
    /**
     * 
     * @type {Challenge}
     * @memberof ChallengeWebhookPayload
     */
    new_challenge?: Challenge;
    /**
     * 
     * @type {Challenge}
     * @memberof ChallengeWebhookPayload
     */
    old_challenge?: Challenge;
}
/**
 * Describes an available event structure
 * @export
 * @interface EventDescription
 */
export interface EventDescription {
    /**
     * The name of the event, i.e kill-enemy. This will be used in the EventPayload as event_name.
     * @type {string}
     * @memberof EventDescription
     */
    event_name?: string;
    /**
     * A list of required properties - properties that must be set
     * @type {Array<EventProperty>}
     * @memberof EventDescription
     */
    required_properties?: Array<EventProperty>;
    /**
     * A list of optional properties
     * @type {Array<EventProperty>}
     * @memberof EventDescription
     */
    optional_properties?: Array<EventProperty>;
}
/**
 * This holds metadata and is specific to each event type. Please have a look at the documentation to learn which properties need to be set for the event-type you want to send.
 * @export
 * @interface EventMetaData
 */
export interface EventMetaData {
    /**
     * The object that is the source of the action
     * @type {string}
     * @memberof EventMetaData
     */
    action_object?: string;
    /**
     * The object that is the target of the action
     * @type {string}
     * @memberof EventMetaData
     */
    action_subject?: string;
    /**
     * The name of the action
     * @type {string}
     * @memberof EventMetaData
     */
    action_type?: string;
    /**
     * Number of ammonition used
     * @type {number}
     * @memberof EventMetaData
     */
    ammo_used?: number;
    /**
     * A general indicator for number of items (i.e. number of kills in kill-enemy event)
     * @type {number}
     * @memberof EventMetaData
     */
    amount?: number;
    /**
     * The number of ammonition gained
     * @type {number}
     * @memberof EventMetaData
     */
    amount_gained?: number;
    /**
     * The number of amminition given
     * @type {number}
     * @memberof EventMetaData
     */
    amount_given?: number;
    /**
     * The name of an animal
     * @type {string}
     * @memberof EventMetaData
     */
    animal_name?: string;
    /**
     * The \"health\" state of the armor
     * @type {number}
     * @memberof EventMetaData
     */
    armor?: number;
    /**
     * The id of the opponent team
     * @type {string}
     * @memberof EventMetaData
     */
    away_team_id?: string;
    /**
     * The score of the opponent team
     * @type {number}
     * @memberof EventMetaData
     */
    away_score?: number;
    /**
     * An integer value indicating the battle status (map it to an enum for example in your code)
     * @type {number}
     * @memberof EventMetaData
     */
    battle_status?: number;
    /**
     * The name of the bounty
     * @type {string}
     * @memberof EventMetaData
     */
    bounty_name?: string;
    /**
     * The id or name of a building
     * @type {string}
     * @memberof EventMetaData
     */
    building_id?: string;
    /**
     * The level of the building
     * @type {number}
     * @memberof EventMetaData
     */
    building_level?: number;
    /**
     * The name of the card
     * @type {string}
     * @memberof EventMetaData
     */
    card_type?: string;
    /**
     * The name of a character
     * @type {string}
     * @memberof EventMetaData
     */
    character_name?: string;
    /**
     * The id/name of a checkpint
     * @type {string}
     * @memberof EventMetaData
     */
    checkpoint_id?: string;
    /**
     * The x coordinate in your coordinate system, used for example to store position on a map
     * @type {number}
     * @memberof EventMetaData
     */
    coordinate_x?: number;
    /**
     * The y coordinate in your coordinate system, used for example to store position on a map
     * @type {number}
     * @memberof EventMetaData
     */
    coordinate_y?: number;
    /**
     * The name of a crew
     * @type {string}
     * @memberof EventMetaData
     */
    crew_name?: string;
    /**
     * The amount of damage
     * @type {number}
     * @memberof EventMetaData
     */
    damage_amount?: number;
    /**
     * The distance measured in any coordinate system of your choice. Please note: This is an integer field. If you need more precision multiple your floating point value with 1000 or so to keep the precision but storing it as an integer value
     * @type {number}
     * @memberof EventMetaData
     */
    distance?: number;
    /**
     * The duration in any unit you like
     * @type {number}
     * @memberof EventMetaData
     */
    duration?: number;
    /**
     * The effect id or name
     * @type {string}
     * @memberof EventMetaData
     */
    effect_id?: string;
    /**
     * The character type or name of an enemy
     * @type {string}
     * @memberof EventMetaData
     */
    enemy_character?: string;
    /**
     * The type of an enemy
     * @type {string}
     * @memberof EventMetaData
     */
    enemy_type?: string;
    /**
     * The event type
     * @type {string}
     * @memberof EventMetaData
     */
    event_type?: string;
    /**
     * The number of fuel consumed
     * @type {number}
     * @memberof EventMetaData
     */
    fuel_consumed?: number;
    /**
     * The health
     * @type {number}
     * @memberof EventMetaData
     */
    health?: number;
    /**
     * The type of a hit (i.e. head, torso, leg)
     * @type {string}
     * @memberof EventMetaData
     */
    hit_type?: string;
    /**
     * The id or name of your or the home team
     * @type {string}
     * @memberof EventMetaData
     */
    home_team_id?: string;
    /**
     * The score of your or the home team
     * @type {number}
     * @memberof EventMetaData
     */
    home_score?: number;
    /**
     * The id of an item
     * @type {string}
     * @memberof EventMetaData
     */
    item_id?: string;
    /**
     * The name of an item
     * @type {string}
     * @memberof EventMetaData
     */
    item_name?: string;
    /**
     * The type of an item
     * @type {string}
     * @memberof EventMetaData
     */
    item_type?: string;
    /**
     * The type of a kill
     * @type {string}
     * @memberof EventMetaData
     */
    kill_type?: string;
    /**
     * The position in a lap
     * @type {number}
     * @memberof EventMetaData
     */
    lap_position?: number;
    /**
     * The id of the level
     * @type {string}
     * @memberof EventMetaData
     */
    level_id?: string;
    /**
     * The name of a map
     * @type {string}
     * @memberof EventMetaData
     */
    map_name?: string;
    /**
     * The name of a section of a map
     * @type {string}
     * @memberof EventMetaData
     */
    map_section_name?: string;
    /**
     * The mission id
     * @type {string}
     * @memberof EventMetaData
     */
    mission_id?: string;
    /**
     * The name of the player character
     * @type {string}
     * @memberof EventMetaData
     */
    player_character?: string;
    /**
     * The id of a puzzle
     * @type {number}
     * @memberof EventMetaData
     */
    puzzle_id?: number;
    /**
     * The position within a race
     * @type {number}
     * @memberof EventMetaData
     */
    race_position?: number;
    /**
     * The realm
     * @type {string}
     * @memberof EventMetaData
     */
    realm?: string;
    /**
     * The time required involed in this event. I.e. in a reach-checkpoint event this could be the time in seconds required to reach that checkpoint from the last checkpoint.
     * @type {number}
     * @memberof EventMetaData
     */
    required_time?: number;
    /**
     * The name/id of the resource gained
     * @type {string}
     * @memberof EventMetaData
     */
    resource_gained?: string;
    /**
     * The name/id of the resource given (to someone else)
     * @type {string}
     * @memberof EventMetaData
     */
    resource_given?: string;
    /**
     * The name of the resource
     * @type {string}
     * @memberof EventMetaData
     */
    resource_name?: string;
    /**
     * The id of the round
     * @type {number}
     * @memberof EventMetaData
     */
    round_id?: number;
    /**
     * The type of the round
     * @type {string}
     * @memberof EventMetaData
     */
    round_type?: string;
    /**
     * The score
     * @type {number}
     * @memberof EventMetaData
     */
    score?: number;
    /**
     * The type of the stats item
     * @type {string}
     * @memberof EventMetaData
     */
    stat_type?: string;
    /**
     * The timing condition
     * @type {string}
     * @memberof EventMetaData
     */
    time_condition?: string;
    /**
     * The id of the transport
     * @type {string}
     * @memberof EventMetaData
     */
    transport_id?: string;
    /**
     * The name/id of a type
     * @type {string}
     * @memberof EventMetaData
     */
    type?: string;
    /**
     * The name/id of a unit type
     * @type {string}
     * @memberof EventMetaData
     */
    unit_type?: string;
    /**
     * The name of the upgrade
     * @type {string}
     * @memberof EventMetaData
     */
    upgrade_type?: string;
    /**
     * The action taken on a weapon (i.e. infrared-activated)
     * @type {string}
     * @memberof EventMetaData
     */
    weapon_action?: string;
    /**
     * The id of the weapon
     * @type {string}
     * @memberof EventMetaData
     */
    weapon_id?: string;
    /**
     * The type of the weapon
     * @type {string}
     * @memberof EventMetaData
     */
    weapon_type?: string;
    /**
     * The name/id of a weapon used in a kill or similar event
     * @type {string}
     * @memberof EventMetaData
     */
    weapon_used?: string;
    /**
     * The name of the zone
     * @type {string}
     * @memberof EventMetaData
     */
    zone_name?: string;
}
/**
 * Events are the engine and driver for challenges, battle passes and leaderboards within the SCILL ecosystem. They are a simple, yet powerful data structure. The idea is, that you just send events for actions and things that happen in your game or application. SCILL leverages these info to update and progress challenges or to figure out the users score within a leaderboard. You don't have to handle any state in your application or game, as everything is done by SCILL.
 * @export
 * @interface EventPayload
 */
export interface EventPayload {
    /**
     * This is your user id. You can set this to whatever you like, either your real user id or an obfuscated user id. However you need to be consistent here. Events linked to this user id only track if challenges or battle passes are unlocked with the same user id.
     * @type {string}
     * @memberof EventPayload
     */
    user_id?: string;
    /**
     * This is required if event_type is single and identifies a session. This can be anything used to group events together. For example this can be a level or a match id.
     * @type {string}
     * @memberof EventPayload
     */
    session_id?: string;
    /**
     * This is the event type as a string. These have predefined event names for many games and applications. It’s wise to use those as this allows us to analyse data and help you balancing your application or game.
     * @type {string}
     * @memberof EventPayload
     */
    event_name?: string;
    /**
     * This is either single or group. You can send multiple events in one request (group) or send events in sequence. Please note, that depending on your tier you might run into rate limits.
     * @type {string}
     * @memberof EventPayload
     */
    event_type?: string;
    /**
     * 
     * @type {EventMetaData}
     * @memberof EventPayload
     */
    meta_data?: EventMetaData;
    /**
     * Provide an optional team id that will be used in leaderboards to group results of teams.
     * @type {string}
     * @memberof EventPayload
     */
    team_id?: string;
}
/**
 * This object holds information about a proporty of an event. Events have required and optional properties.
 * @export
 * @interface EventProperty
 */
export interface EventProperty {
    /**
     * The name of the property. Is the field value in the event payloads meta_data.
     * @type {string}
     * @memberof EventProperty
     */
    property_name?: string;
    /**
     * The type of the property. Can be number or string.
     * @type {string}
     * @memberof EventProperty
     */
    property_type?: string;
}
/**
 * Requesting an access token requires this object to be sent containing the user id of your user. The user id can be anything (we dont care) but it must be consistent for the lifetime of the user.
 * @export
 * @interface ForeignUserIdentifier
 */
export interface ForeignUserIdentifier {
    /**
     * Any string allowed, this is the foreign user identifier that has no relation in the SCILL database and the user is unkown to SCILL.
     * @type {string}
     * @memberof ForeignUserIdentifier
     */
    user_id: string;
}
/**
 * The Leaderboard object contains information about the leaderboard itself like the name and the id, but also contains actual rankings for users and teams.
 * @export
 * @interface Leaderboard
 */
export interface Leaderboard {
    /**
     * The id of the leaderboard
     * @type {string}
     * @memberof Leaderboard
     */
    leaderboard_id?: string;
    /**
     * The name of the leaderboard
     * @type {string}
     * @memberof Leaderboard
     */
    name?: string;
    /**
     * An array of LeaderboardRanking Items for individual users
     * @type {Array<LeaderboardRanking>}
     * @memberof Leaderboard
     */
    grouped_by_users?: Array<LeaderboardRanking>;
    /**
     * An array of LeaderboardRanking Items for teams. Provide a team_id in the event payload to also create leaderboards for teams
     * @type {Array<LeaderboardRanking>}
     * @memberof Leaderboard
     */
    grouped_by_teams?: Array<LeaderboardRanking>;
    /**
     * The total number of team rankings available in the leaderboard
     * @type {number}
     * @memberof Leaderboard
     */
    num_teams?: number;
    /**
     * The total number of user rankings available in the leaderboard
     * @type {number}
     * @memberof Leaderboard
     */
    num_users?: number;
}
/**
 * The Leaderboard object contains information about the leaderboard itself like the name and the id
 * @export
 * @interface LeaderboardInfo
 */
export interface LeaderboardInfo {
    /**
     * The id of the app
     * @type {string}
     * @memberof LeaderboardInfo
     */
    app_id?: string;
    /**
     * The id of the leaderboard
     * @type {string}
     * @memberof LeaderboardInfo
     */
    leaderboard_id?: string;
    /**
     * The name of the leaderboard
     * @type {string}
     * @memberof LeaderboardInfo
     */
    name?: string;
    /**
     * The event type that triggers this leaderboard
     * @type {string}
     * @memberof LeaderboardInfo
     */
    event_type?: string;
    /**
     * True if this leaderboard sorts the score ascending or false if the ranking is defined by a descending score.
     * @type {boolean}
     * @memberof LeaderboardInfo
     */
    sort_order_ascending?: boolean;
}
/**
 * You get these object if you query the leaderboard ranking for a specific user. Only the requested user will be returned.
 * @export
 * @interface LeaderboardMemberRanking
 */
export interface LeaderboardMemberRanking {
    /**
     * The id of the leaderboard
     * @type {string}
     * @memberof LeaderboardMemberRanking
     */
    leaderboard_id?: string;
    /**
     * The name of the leaderboard
     * @type {string}
     * @memberof LeaderboardMemberRanking
     */
    name?: string;
    /**
     * 
     * @type {LeaderboardRanking}
     * @memberof LeaderboardMemberRanking
     */
    member?: LeaderboardRanking;
}
/**
 * The ranking for the user or team in the leaderboard
 * @export
 * @interface LeaderboardRanking
 */
export interface LeaderboardRanking {
    /**
     * The id of the user - its the same user id you used to create the access token and the same user id you used to send the events
     * @type {string}
     * @memberof LeaderboardRanking
     */
    member_id?: string;
    /**
     * Indicates what type this entry is, it's either user or team
     * @type {string}
     * @memberof LeaderboardRanking
     */
    member_type?: string;
    /**
     * The score achieved as an integer value. If you want to store floats, for example laptimes you need to convert them into an int before (i.e. multiply by 100 to get hundreds of seconds and format back to float in UI)
     * @type {number}
     * @memberof LeaderboardRanking
     */
    score?: number;
    /**
     * The position within the leaderboard
     * @type {number}
     * @memberof LeaderboardRanking
     */
    rank?: number;
    /**
     * 
     * @type {UserInfo}
     * @memberof LeaderboardRanking
     */
    additional_info?: UserInfo;
}
/**
 * Contains info about rank and score
 * @export
 * @interface LeaderboardScore
 */
export interface LeaderboardScore {
    /**
     * The score achieved as an integer value. If you want to store floats, for example laptimes you need to convert them into an int before (i.e. multiply by 100 to get hundreds of seconds and format back to float in UI)
     * @type {number}
     * @memberof LeaderboardScore
     */
    score?: number;
    /**
     * The position within the leaderboard
     * @type {number}
     * @memberof LeaderboardScore
     */
    rank?: number;
}
/**
 * The payload used for realtime updates and webhooks if a leaderboard is updated.
 * @export
 * @interface LeaderboardUpdatePayload
 */
export interface LeaderboardUpdatePayload {
    /**
     * The type of the webhook, in this case it is leaderboard-ranking-changed
     * @type {string}
     * @memberof LeaderboardUpdatePayload
     */
    webhook_type?: string;
    /**
     * 
     * @type {LeaderboardInfo}
     * @memberof LeaderboardUpdatePayload
     */
    leaderboard_data?: LeaderboardInfo;
    /**
     * 
     * @type {LeaderboardRanking}
     * @memberof LeaderboardUpdatePayload
     */
    member_data?: LeaderboardRanking;
    /**
     * 
     * @type {LeaderboardScore}
     * @memberof LeaderboardUpdatePayload
     */
    old_leaderboard_ranking?: LeaderboardScore;
    /**
     * 
     * @type {LeaderboardScore}
     * @memberof LeaderboardUpdatePayload
     */
    new_leaderboard_ranking?: LeaderboardScore;
}
/**
 * This object is sent via Webhook or notifications of type leaderboard-changed.
 * @export
 * @interface LeaderboardV2Changed
 */
export interface LeaderboardV2Changed {
    /**
     * The type of the notification. If you receive this payload, it's most likely leaderboard-changed.
     * @type {string}
     * @memberof LeaderboardV2Changed
     */
    webhook_type?: string;
    /**
     * 
     * @type {LeaderboardV2Info}
     * @memberof LeaderboardV2Changed
     */
    old_leaderboard?: LeaderboardV2Info;
    /**
     * 
     * @type {LeaderboardV2Info}
     * @memberof LeaderboardV2Changed
     */
    new_leaderboard?: LeaderboardV2Info;
}
/**
 * The Leaderboard object contains information about the leaderboard itself like the name and the id
 * @export
 * @interface LeaderboardV2Info
 */
export interface LeaderboardV2Info {
    /**
     * The id of the app
     * @type {string}
     * @memberof LeaderboardV2Info
     */
    app_id?: string;
    /**
     * The id of the leaderboard
     * @type {string}
     * @memberof LeaderboardV2Info
     */
    leaderboard_id?: string;
    /**
     * The name of the leaderboard
     * @type {string}
     * @memberof LeaderboardV2Info
     */
    leaderboard_name?: string;
    /**
     * The event type that triggers this leaderboard
     * @type {string}
     * @memberof LeaderboardV2Info
     */
    event_type?: string;
    /**
     * True if this leaderboard sorts the score ascending or false if the ranking is defined by a descending score.
     * @type {boolean}
     * @memberof LeaderboardV2Info
     */
    sort_order_ascending?: boolean;
}
/**
 * The ranking for the user or team in the leaderboard
 * @export
 * @interface LeaderboardV2Member
 */
export interface LeaderboardV2Member {
    /**
     * The id of the user - its the same user id you used to create the access token and the same user id you used to send the events
     * @type {string}
     * @memberof LeaderboardV2Member
     */
    member_id?: string;
    /**
     * Indicates what type this entry is, it's either user or team
     * @type {string}
     * @memberof LeaderboardV2Member
     */
    member_type?: string;
    /**
     * The score achieved as an integer value. If you want to store floats, for example laptimes you need to convert them into an int before (i.e. multiply by 100 to get hundreds of seconds and format back to float in UI)
     * @type {number}
     * @memberof LeaderboardV2Member
     */
    score?: number;
    /**
     * The position within the leaderboard
     * @type {number}
     * @memberof LeaderboardV2Member
     */
    rank?: number;
    /**
     * Returns an array of the LeaderboardMemberMetadata objects containing user ranking metadata information
     * @type {Array<LeaderboardV2MemberMetadata>}
     * @memberof LeaderboardV2Member
     */
    metadata_results?: Array<LeaderboardV2MemberMetadata>;
    /**
     * 
     * @type {UserInfo}
     * @memberof LeaderboardV2Member
     */
    additional_info?: UserInfo;
}
/**
 * The object containing secondary metadata ranking information, useful for tied scores on the main tracking parameter
 * @export
 * @interface LeaderboardV2MemberMetadata
 */
export interface LeaderboardV2MemberMetadata {
    /**
     * The event type key used for ranking
     * @type {string}
     * @memberof LeaderboardV2MemberMetadata
     */
    key?: string;
    /**
     * Determines if the user is ranked for that event type key. If false, no score and rank will be provided
     * @type {boolean}
     * @memberof LeaderboardV2MemberMetadata
     */
    ranked?: boolean;
    /**
     * The score achieved as an integer value. If you want to store floats, for example laptimes you need to convert them into an int before (i.e. multiply by 100 to get hundreds of seconds and format back to float in UI)
     * @type {number}
     * @memberof LeaderboardV2MemberMetadata
     */
    score?: number;
    /**
     * The position within the leaderboard
     * @type {number}
     * @memberof LeaderboardV2MemberMetadata
     */
    rank?: number;
}
/**
 * The Leaderboard object contains information about the leaderboard itself like the name and the id
 * @export
 * @interface LeaderboardV2MemberRanking
 */
export interface LeaderboardV2MemberRanking {
    /**
     * The id of the leaderboard
     * @type {string}
     * @memberof LeaderboardV2MemberRanking
     */
    leaderboard_id?: string;
    /**
     * The name of the leaderboard
     * @type {string}
     * @memberof LeaderboardV2MemberRanking
     */
    leaderboard_name?: string;
    /**
     * Determines the results sort order. If true, the order is ascending, otherwise, it's descending.
     * @type {boolean}
     * @memberof LeaderboardV2MemberRanking
     */
    leaderboard_sort_order_ascending?: boolean;
    /**
     * Returns the LeaderboardMember object containing user ranking information
     * @type {Array<LeaderboardV2Member>}
     * @memberof LeaderboardV2MemberRanking
     */
    leaderboard_member?: Array<LeaderboardV2Member>;
}
/**
 * You get this object if you query the leaderboard ranking for a specific user. Only the requested user will be returned.
 * @export
 * @interface LeaderboardV2MemberTypeRanking
 */
export interface LeaderboardV2MemberTypeRanking {
    /**
     * The total number of members included in the results
     * @type {number}
     * @memberof LeaderboardV2MemberTypeRanking
     */
    count?: number;
    /**
     * An array of LeaderboardMember objects
     * @type {Array<LeaderboardV2Member>}
     * @memberof LeaderboardV2MemberTypeRanking
     */
    members?: Array<LeaderboardV2Member>;
}
/**
 * The Leaderboard object contains information about the leaderboard itself like the name and the id, but also contains actual rankings for users and teams.
 * @export
 * @interface LeaderboardV2Results
 */
export interface LeaderboardV2Results {
    /**
     * The id of the leaderboard
     * @type {string}
     * @memberof LeaderboardV2Results
     */
    leaderboard_id?: string;
    /**
     * The name of the leaderboard
     * @type {string}
     * @memberof LeaderboardV2Results
     */
    leaderboard_name?: string;
    /**
     * Determines the results sort order. If true, the order is ascending, otherwise, it's descending.
     * @type {boolean}
     * @memberof LeaderboardV2Results
     */
    leaderboard_sort_order_ascending?: boolean;
    /**
     * 
     * @type {LeaderboardV2ResultsLeaderboardResultsByMemberType}
     * @memberof LeaderboardV2Results
     */
    leaderboard_results_by_member_type?: LeaderboardV2ResultsLeaderboardResultsByMemberType;
}
/**
 * This object uses two keys - \"user\" and \"team\", both of which contain ranking info
 * @export
 * @interface LeaderboardV2ResultsLeaderboardResultsByMemberType
 */
export interface LeaderboardV2ResultsLeaderboardResultsByMemberType {
    /**
     * 
     * @type {LeaderboardV2MemberTypeRanking}
     * @memberof LeaderboardV2ResultsLeaderboardResultsByMemberType
     */
    team?: LeaderboardV2MemberTypeRanking;
    /**
     * 
     * @type {LeaderboardV2MemberTypeRanking}
     * @memberof LeaderboardV2ResultsLeaderboardResultsByMemberType
     */
    user?: LeaderboardV2MemberTypeRanking;
}
/**
 * The payload used for realtime updates and webhooks if a leaderboard is updated.
 * @export
 * @interface LeaderboardV2UpdatePayload
 */
export interface LeaderboardV2UpdatePayload {
    /**
     * The type of the webhook, in this case it is leaderboard-ranking-changed
     * @type {string}
     * @memberof LeaderboardV2UpdatePayload
     */
    webhook_type?: string;
    /**
     * 
     * @type {LeaderboardV2Info}
     * @memberof LeaderboardV2UpdatePayload
     */
    leaderboard_data?: LeaderboardV2Info;
    /**
     * 
     * @type {LeaderboardV2Member}
     * @memberof LeaderboardV2UpdatePayload
     */
    member_data?: LeaderboardV2Member;
    /**
     * 
     * @type {LeaderboardScore}
     * @memberof LeaderboardV2UpdatePayload
     */
    old_leaderboard_ranking?: LeaderboardScore;
    /**
     * 
     * @type {LeaderboardScore}
     * @memberof LeaderboardV2UpdatePayload
     */
    new_leaderboard_ranking?: LeaderboardScore;
}
/**
 * Errors are reported using this structure. Error messages are human readable and will be translated (if available) in the language provided by the language query parameter.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message: string;
}
/**
 * Realtime updates are implemented via MQTT - a resource efficient real time message system. Each user has it's own channel in our MQTT system that you need to request from the backend. This structure returns the topic for the user provided with the access token.
 * @export
 * @interface NotificationTopic
 */
export interface NotificationTopic {
    /**
     * 
     * @type {string}
     * @memberof NotificationTopic
     */
    topic: string;
}
/**
 * 
 * @export
 * @interface SocketToken
 */
export interface SocketToken {
    /**
     * 
     * @type {string}
     * @memberof SocketToken
     */
    socket_token: string;
}
/**
 * 
 * @export
 * @interface UnknownChallengeError
 */
export interface UnknownChallengeError {
    /**
     * The error message
     * @type {string}
     * @memberof UnknownChallengeError
     */
    error?: string;
    /**
     * Machine readable error message
     * @type {string}
     * @memberof UnknownChallengeError
     */
    error_slug?: string;
    /**
     * HTTP status code of this error message'
     * @type {number}
     * @memberof UnknownChallengeError
     */
    status_code?: number;
}
/**
 * Can be any object that is attached to the user. You can set these values in the user service. For example you can provide a user name and an avatar image url.
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * The user name of the user
     * @type {string}
     * @memberof UserInfo
     */
    username?: string;
    /**
     * The name or URL of an avatar image for a user.
     * @type {string}
     * @memberof UserInfo
     */
    avatar_image?: string;
}
/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get an access token for any user identifier signed with the API-Key
         * @param {ForeignUserIdentifier} body Foreign user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAccessToken(body: ForeignUserIdentifier, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling generateAccessToken.');
            }
            const localVarPath = `/api/v1/auth/access-token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ForeignUserIdentifier" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever the specified leaderboard changes.
         * @summary Get MQTT topic for leaderboard
         * @param {string} leaderboard_id The id of the leaderboard you want to get notified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardNotificationTopic(leaderboard_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'leaderboard_id' is not null or undefined
            if (leaderboard_id === null || leaderboard_id === undefined) {
                throw new RequiredError('leaderboard_id','Required parameter leaderboard_id was null or undefined when calling getLeaderboardNotificationTopic.');
            }
            const localVarPath = `/api/v1/auth/leaderboard-topic-link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (leaderboard_id !== undefined) {
                localVarQueryParameter['leaderboard_id'] = leaderboard_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever a battle pass changes.
         * @summary Get a topic to be used with an MQTT client to receive real time updates whenever a battle pass or challenges and levels within the battle pass change
         * @param {string} battle_pass_id The battle pass you want to get notified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBattlePassNotificationTopic(battle_pass_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'battle_pass_id' is not null or undefined
            if (battle_pass_id === null || battle_pass_id === undefined) {
                throw new RequiredError('battle_pass_id','Required parameter battle_pass_id was null or undefined when calling getUserBattlePassNotificationTopic.');
            }
            const localVarPath = `/api/v1/auth/user-battle-pass-topic-link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (battle_pass_id !== undefined) {
                localVarQueryParameter['battle_pass_id'] = battle_pass_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever the challenge changes.
         * @summary Get a topic to be used with an MQTT client to receive real time updates whenever the specified challenge changes.
         * @param {string} challenge_id The challenge id you want to get notified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserChallengeNotificationTopic(challenge_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'challenge_id' is not null or undefined
            if (challenge_id === null || challenge_id === undefined) {
                throw new RequiredError('challenge_id','Required parameter challenge_id was null or undefined when calling getUserChallengeNotificationTopic.');
            }
            const localVarPath = `/api/v1/auth/user-challenge-topic-link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (challenge_id !== undefined) {
                localVarQueryParameter['challenge_id'] = challenge_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever challenges for the user provided by the access token change.
         * @summary Get a topic to be used with an MQTT client to receive real time updates whenever challenges for the user provided by the access token changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserChallengesNotificationTopic(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/auth/user-challenges-topic-link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns additional info object with usernames and avatar image for a user which is used in the leaderboard system
         * @summary Get additional info stored per user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/user-additional-info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets user info like username and avatar image which is returned as part of the user rankings in leaderboards.
         * @summary Set additional info stored per user
         * @param {UserInfo} body UserInfo object stored in the SCILL database for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserInfo(body: UserInfo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setUserInfo.');
            }
            const localVarPath = `/api/v1/user-additional-info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get an access token for any user identifier signed with the API-Key
         * @param {ForeignUserIdentifier} body Foreign user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAccessToken(body: ForeignUserIdentifier, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).generateAccessToken(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever the specified leaderboard changes.
         * @summary Get MQTT topic for leaderboard
         * @param {string} leaderboard_id The id of the leaderboard you want to get notified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardNotificationTopic(leaderboard_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationTopic> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).getLeaderboardNotificationTopic(leaderboard_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever a battle pass changes.
         * @summary Get a topic to be used with an MQTT client to receive real time updates whenever a battle pass or challenges and levels within the battle pass change
         * @param {string} battle_pass_id The battle pass you want to get notified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBattlePassNotificationTopic(battle_pass_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationTopic> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).getUserBattlePassNotificationTopic(battle_pass_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever the challenge changes.
         * @summary Get a topic to be used with an MQTT client to receive real time updates whenever the specified challenge changes.
         * @param {string} challenge_id The challenge id you want to get notified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserChallengeNotificationTopic(challenge_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationTopic> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).getUserChallengeNotificationTopic(challenge_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever challenges for the user provided by the access token change.
         * @summary Get a topic to be used with an MQTT client to receive real time updates whenever challenges for the user provided by the access token changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserChallengesNotificationTopic(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationTopic> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).getUserChallengesNotificationTopic(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns additional info object with usernames and avatar image for a user which is used in the leaderboard system
         * @summary Get additional info stored per user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).getUserInfo(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets user info like username and avatar image which is returned as part of the user rankings in leaderboards.
         * @summary Set additional info stored per user
         * @param {UserInfo} body UserInfo object stored in the SCILL database for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserInfo(body: UserInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).setUserInfo(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get an access token for any user identifier signed with the API-Key
         * @param {ForeignUserIdentifier} body Foreign user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAccessToken(body: ForeignUserIdentifier, options?: any) {
            return AuthApiFp(configuration).generateAccessToken(body, options)(fetch, basePath);
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever the specified leaderboard changes.
         * @summary Get MQTT topic for leaderboard
         * @param {string} leaderboard_id The id of the leaderboard you want to get notified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardNotificationTopic(leaderboard_id: string, options?: any) {
            return AuthApiFp(configuration).getLeaderboardNotificationTopic(leaderboard_id, options)(fetch, basePath);
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever a battle pass changes.
         * @summary Get a topic to be used with an MQTT client to receive real time updates whenever a battle pass or challenges and levels within the battle pass change
         * @param {string} battle_pass_id The battle pass you want to get notified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBattlePassNotificationTopic(battle_pass_id: string, options?: any) {
            return AuthApiFp(configuration).getUserBattlePassNotificationTopic(battle_pass_id, options)(fetch, basePath);
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever the challenge changes.
         * @summary Get a topic to be used with an MQTT client to receive real time updates whenever the specified challenge changes.
         * @param {string} challenge_id The challenge id you want to get notified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserChallengeNotificationTopic(challenge_id: string, options?: any) {
            return AuthApiFp(configuration).getUserChallengeNotificationTopic(challenge_id, options)(fetch, basePath);
        },
        /**
         * Get a topic to be used with an MQTT client to receive real time updates whenever challenges for the user provided by the access token change.
         * @summary Get a topic to be used with an MQTT client to receive real time updates whenever challenges for the user provided by the access token changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserChallengesNotificationTopic(options?: any) {
            return AuthApiFp(configuration).getUserChallengesNotificationTopic(options)(fetch, basePath);
        },
        /**
         * Returns additional info object with usernames and avatar image for a user which is used in the leaderboard system
         * @summary Get additional info stored per user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any) {
            return AuthApiFp(configuration).getUserInfo(options)(fetch, basePath);
        },
        /**
         * Sets user info like username and avatar image which is returned as part of the user rankings in leaderboards.
         * @summary Set additional info stored per user
         * @param {UserInfo} body UserInfo object stored in the SCILL database for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserInfo(body: UserInfo, options?: any) {
            return AuthApiFp(configuration).setUserInfo(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Get an access token for any user identifier signed with the API-Key
     * @param {ForeignUserIdentifier} body Foreign user identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public generateAccessToken(body: ForeignUserIdentifier, options?: any) {
        return AuthApiFp(this.configuration).generateAccessToken(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get a topic to be used with an MQTT client to receive real time updates whenever the specified leaderboard changes.
     * @summary Get MQTT topic for leaderboard
     * @param {string} leaderboard_id The id of the leaderboard you want to get notified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getLeaderboardNotificationTopic(leaderboard_id: string, options?: any) {
        return AuthApiFp(this.configuration).getLeaderboardNotificationTopic(leaderboard_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a topic to be used with an MQTT client to receive real time updates whenever a battle pass changes.
     * @summary Get a topic to be used with an MQTT client to receive real time updates whenever a battle pass or challenges and levels within the battle pass change
     * @param {string} battle_pass_id The battle pass you want to get notified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserBattlePassNotificationTopic(battle_pass_id: string, options?: any) {
        return AuthApiFp(this.configuration).getUserBattlePassNotificationTopic(battle_pass_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a topic to be used with an MQTT client to receive real time updates whenever the challenge changes.
     * @summary Get a topic to be used with an MQTT client to receive real time updates whenever the specified challenge changes.
     * @param {string} challenge_id The challenge id you want to get notified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserChallengeNotificationTopic(challenge_id: string, options?: any) {
        return AuthApiFp(this.configuration).getUserChallengeNotificationTopic(challenge_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a topic to be used with an MQTT client to receive real time updates whenever challenges for the user provided by the access token change.
     * @summary Get a topic to be used with an MQTT client to receive real time updates whenever challenges for the user provided by the access token changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserChallengesNotificationTopic(options?: any) {
        return AuthApiFp(this.configuration).getUserChallengesNotificationTopic(options)(this.fetch, this.basePath);
    }

    /**
     * Returns additional info object with usernames and avatar image for a user which is used in the leaderboard system
     * @summary Get additional info stored per user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserInfo(options?: any) {
        return AuthApiFp(this.configuration).getUserInfo(options)(this.fetch, this.basePath);
    }

    /**
     * Sets user info like username and avatar image which is returned as part of the user rankings in leaderboards.
     * @summary Set additional info stored per user
     * @param {UserInfo} body UserInfo object stored in the SCILL database for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public setUserInfo(body: UserInfo, options?: any) {
        return AuthApiFp(this.configuration).setUserInfo(body, options)(this.fetch, this.basePath);
    }

}
/**
 * BattlePassesApi - fetch parameter creator
 * @export
 */
export const BattlePassesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a given battle pass level by id
         * @summary Activate a given battle pass level by id
         * @param {string} app_id The app id
         * @param {string} level_id The id of the battle pass level.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateBattlePassLevel(app_id: string, level_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling activateBattlePassLevel.');
            }
            // verify required parameter 'level_id' is not null or undefined
            if (level_id === null || level_id === undefined) {
                throw new RequiredError('level_id','Required parameter level_id was null or undefined when calling activateBattlePassLevel.');
            }
            const localVarPath = `/api/v1/battle-pass-levels/{appId}/activate/{levelId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"levelId"}}`, encodeURIComponent(String(level_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Claim the battle pass level id
         * @summary Claim the battle pass level reward. This will trigger a Webhook that you can use to unlock the reward on server side. If you don't have a server you can also unlock in the client application after receiving a positive response.
         * @param {string} app_id The app id
         * @param {string} level_id The id of the battle pass level.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimBattlePassLevelReward(app_id: string, level_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling claimBattlePassLevelReward.');
            }
            // verify required parameter 'level_id' is not null or undefined
            if (level_id === null || level_id === undefined) {
                throw new RequiredError('level_id','Required parameter level_id was null or undefined when calling claimBattlePassLevelReward.');
            }
            const localVarPath = `/api/v1/battle-pass-levels/{appId}/claim/{levelId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"levelId"}}`, encodeURIComponent(String(level_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get active battle passes for the app
         * @summary Get battle passes
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBattlePasses(app_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getActiveBattlePasses.');
            }
            const localVarPath = `/api/v1/battle-passes/{appId}/active`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all battle pass levels for an app
         * @summary Get battle pass levels for an app (from all battle passes)
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBattlePassLevels(app_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getAllBattlePassLevels.');
            }
            const localVarPath = `/api/v1/battle-pass-levels/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get battle pass for the product with id
         * @summary Get battle pass by id
         * @param {string} app_id The app id
         * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePass(app_id: string, battle_pass_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getBattlePass.');
            }
            // verify required parameter 'battle_pass_id' is not null or undefined
            if (battle_pass_id === null || battle_pass_id === undefined) {
                throw new RequiredError('battle_pass_id','Required parameter battle_pass_id was null or undefined when calling getBattlePass.');
            }
            const localVarPath = `/api/v1/battle-passes/{appId}/single/{battlePassId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"battlePassId"}}`, encodeURIComponent(String(battle_pass_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get battle pass levels for a battle pass
         * @summary Get battle pass levels for a battle pass
         * @param {string} app_id The app id
         * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePassLevels(app_id: string, battle_pass_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getBattlePassLevels.');
            }
            // verify required parameter 'battle_pass_id' is not null or undefined
            if (battle_pass_id === null || battle_pass_id === undefined) {
                throw new RequiredError('battle_pass_id','Required parameter battle_pass_id was null or undefined when calling getBattlePassLevels.');
            }
            const localVarPath = `/api/v1/battle-pass-levels/{appId}/{battlePassId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"battlePassId"}}`, encodeURIComponent(String(battle_pass_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get battle passes for the product
         * @summary Get battle passes
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePasses(app_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getBattlePasses.');
            }
            const localVarPath = `/api/v1/battle-passes/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get unlocked battle passes for the user encoded in the access token
         * @summary Get battle passes unlocked by the user
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlockedBattlePasses(app_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getUnlockedBattlePasses.');
            }
            const localVarPath = `/api/v1/battle-passes/{appId}/unlocked`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlock the battle pass for a user
         * @summary Unlock the battle pass for the user specified in the access token
         * @param {string} app_id The app id
         * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {BattlePassUnlockPayload} [body] Provide purchase info for the battle pass
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockBattlePass(app_id: string, battle_pass_id: string, body?: BattlePassUnlockPayload, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling unlockBattlePass.');
            }
            // verify required parameter 'battle_pass_id' is not null or undefined
            if (battle_pass_id === null || battle_pass_id === undefined) {
                throw new RequiredError('battle_pass_id','Required parameter battle_pass_id was null or undefined when calling unlockBattlePass.');
            }
            const localVarPath = `/api/v1/battle-passes/{appId}/unlock/{battlePassId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"battlePassId"}}`, encodeURIComponent(String(battle_pass_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BattlePassUnlockPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BattlePassesApi - functional programming interface
 * @export
 */
export const BattlePassesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Activate a given battle pass level by id
         * @summary Activate a given battle pass level by id
         * @param {string} app_id The app id
         * @param {string} level_id The id of the battle pass level.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateBattlePassLevel(app_id: string, level_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).activateBattlePassLevel(app_id, level_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Claim the battle pass level id
         * @summary Claim the battle pass level reward. This will trigger a Webhook that you can use to unlock the reward on server side. If you don't have a server you can also unlock in the client application after receiving a positive response.
         * @param {string} app_id The app id
         * @param {string} level_id The id of the battle pass level.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimBattlePassLevelReward(app_id: string, level_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).claimBattlePassLevelReward(app_id, level_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get active battle passes for the app
         * @summary Get battle passes
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBattlePasses(app_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BattlePass>> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).getActiveBattlePasses(app_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all battle pass levels for an app
         * @summary Get battle pass levels for an app (from all battle passes)
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBattlePassLevels(app_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BattlePassLevel>> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).getAllBattlePassLevels(app_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get battle pass for the product with id
         * @summary Get battle pass by id
         * @param {string} app_id The app id
         * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePass(app_id: string, battle_pass_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BattlePass> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).getBattlePass(app_id, battle_pass_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get battle pass levels for a battle pass
         * @summary Get battle pass levels for a battle pass
         * @param {string} app_id The app id
         * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePassLevels(app_id: string, battle_pass_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BattlePassLevel>> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).getBattlePassLevels(app_id, battle_pass_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get battle passes for the product
         * @summary Get battle passes
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePasses(app_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BattlePass>> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).getBattlePasses(app_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get unlocked battle passes for the user encoded in the access token
         * @summary Get battle passes unlocked by the user
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlockedBattlePasses(app_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BattlePass>> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).getUnlockedBattlePasses(app_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unlock the battle pass for a user
         * @summary Unlock the battle pass for the user specified in the access token
         * @param {string} app_id The app id
         * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {BattlePassUnlockPayload} [body] Provide purchase info for the battle pass
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockBattlePass(app_id: string, battle_pass_id: string, body?: BattlePassUnlockPayload, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BattlePassUnlockInfo> {
            const localVarFetchArgs = BattlePassesApiFetchParamCreator(configuration).unlockBattlePass(app_id, battle_pass_id, body, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BattlePassesApi - factory interface
 * @export
 */
export const BattlePassesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Activate a given battle pass level by id
         * @summary Activate a given battle pass level by id
         * @param {string} app_id The app id
         * @param {string} level_id The id of the battle pass level.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateBattlePassLevel(app_id: string, level_id: string, language?: string, options?: any) {
            return BattlePassesApiFp(configuration).activateBattlePassLevel(app_id, level_id, language, options)(fetch, basePath);
        },
        /**
         * Claim the battle pass level id
         * @summary Claim the battle pass level reward. This will trigger a Webhook that you can use to unlock the reward on server side. If you don't have a server you can also unlock in the client application after receiving a positive response.
         * @param {string} app_id The app id
         * @param {string} level_id The id of the battle pass level.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimBattlePassLevelReward(app_id: string, level_id: string, language?: string, options?: any) {
            return BattlePassesApiFp(configuration).claimBattlePassLevelReward(app_id, level_id, language, options)(fetch, basePath);
        },
        /**
         * Get active battle passes for the app
         * @summary Get battle passes
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBattlePasses(app_id: string, language?: string, options?: any) {
            return BattlePassesApiFp(configuration).getActiveBattlePasses(app_id, language, options)(fetch, basePath);
        },
        /**
         * Get all battle pass levels for an app
         * @summary Get battle pass levels for an app (from all battle passes)
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBattlePassLevels(app_id: string, language?: string, options?: any) {
            return BattlePassesApiFp(configuration).getAllBattlePassLevels(app_id, language, options)(fetch, basePath);
        },
        /**
         * Get battle pass for the product with id
         * @summary Get battle pass by id
         * @param {string} app_id The app id
         * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePass(app_id: string, battle_pass_id: string, language?: string, options?: any) {
            return BattlePassesApiFp(configuration).getBattlePass(app_id, battle_pass_id, language, options)(fetch, basePath);
        },
        /**
         * Get battle pass levels for a battle pass
         * @summary Get battle pass levels for a battle pass
         * @param {string} app_id The app id
         * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePassLevels(app_id: string, battle_pass_id: string, language?: string, options?: any) {
            return BattlePassesApiFp(configuration).getBattlePassLevels(app_id, battle_pass_id, language, options)(fetch, basePath);
        },
        /**
         * Get battle passes for the product
         * @summary Get battle passes
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBattlePasses(app_id: string, language?: string, options?: any) {
            return BattlePassesApiFp(configuration).getBattlePasses(app_id, language, options)(fetch, basePath);
        },
        /**
         * Get unlocked battle passes for the user encoded in the access token
         * @summary Get battle passes unlocked by the user
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlockedBattlePasses(app_id: string, language?: string, options?: any) {
            return BattlePassesApiFp(configuration).getUnlockedBattlePasses(app_id, language, options)(fetch, basePath);
        },
        /**
         * Unlock the battle pass for a user
         * @summary Unlock the battle pass for the user specified in the access token
         * @param {string} app_id The app id
         * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
         * @param {BattlePassUnlockPayload} [body] Provide purchase info for the battle pass
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockBattlePass(app_id: string, battle_pass_id: string, body?: BattlePassUnlockPayload, language?: string, options?: any) {
            return BattlePassesApiFp(configuration).unlockBattlePass(app_id, battle_pass_id, body, language, options)(fetch, basePath);
        },
    };
};

/**
 * BattlePassesApi - object-oriented interface
 * @export
 * @class BattlePassesApi
 * @extends {BaseAPI}
 */
export class BattlePassesApi extends BaseAPI {
    /**
     * Activate a given battle pass level by id
     * @summary Activate a given battle pass level by id
     * @param {string} app_id The app id
     * @param {string} level_id The id of the battle pass level.
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public activateBattlePassLevel(app_id: string, level_id: string, language?: string, options?: any) {
        return BattlePassesApiFp(this.configuration).activateBattlePassLevel(app_id, level_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Claim the battle pass level id
     * @summary Claim the battle pass level reward. This will trigger a Webhook that you can use to unlock the reward on server side. If you don't have a server you can also unlock in the client application after receiving a positive response.
     * @param {string} app_id The app id
     * @param {string} level_id The id of the battle pass level.
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public claimBattlePassLevelReward(app_id: string, level_id: string, language?: string, options?: any) {
        return BattlePassesApiFp(this.configuration).claimBattlePassLevelReward(app_id, level_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get active battle passes for the app
     * @summary Get battle passes
     * @param {string} app_id The app id
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public getActiveBattlePasses(app_id: string, language?: string, options?: any) {
        return BattlePassesApiFp(this.configuration).getActiveBattlePasses(app_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get all battle pass levels for an app
     * @summary Get battle pass levels for an app (from all battle passes)
     * @param {string} app_id The app id
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public getAllBattlePassLevels(app_id: string, language?: string, options?: any) {
        return BattlePassesApiFp(this.configuration).getAllBattlePassLevels(app_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get battle pass for the product with id
     * @summary Get battle pass by id
     * @param {string} app_id The app id
     * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public getBattlePass(app_id: string, battle_pass_id: string, language?: string, options?: any) {
        return BattlePassesApiFp(this.configuration).getBattlePass(app_id, battle_pass_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get battle pass levels for a battle pass
     * @summary Get battle pass levels for a battle pass
     * @param {string} app_id The app id
     * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public getBattlePassLevels(app_id: string, battle_pass_id: string, language?: string, options?: any) {
        return BattlePassesApiFp(this.configuration).getBattlePassLevels(app_id, battle_pass_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get battle passes for the product
     * @summary Get battle passes
     * @param {string} app_id The app id
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public getBattlePasses(app_id: string, language?: string, options?: any) {
        return BattlePassesApiFp(this.configuration).getBattlePasses(app_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get unlocked battle passes for the user encoded in the access token
     * @summary Get battle passes unlocked by the user
     * @param {string} app_id The app id
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public getUnlockedBattlePasses(app_id: string, language?: string, options?: any) {
        return BattlePassesApiFp(this.configuration).getUnlockedBattlePasses(app_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Unlock the battle pass for a user
     * @summary Unlock the battle pass for the user specified in the access token
     * @param {string} app_id The app id
     * @param {string} battle_pass_id The id of the battle pass. It’s the same as in battle_pass_id you received in earlier requests (i.e. getting all active battle passes for a product).
     * @param {BattlePassUnlockPayload} [body] Provide purchase info for the battle pass
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BattlePassesApi
     */
    public unlockBattlePass(app_id: string, battle_pass_id: string, body?: BattlePassUnlockPayload, language?: string, options?: any) {
        return BattlePassesApiFp(this.configuration).unlockBattlePass(app_id, battle_pass_id, body, language, options)(this.fetch, this.basePath);
    }

}
/**
 * ChallengesApi - fetch parameter creator
 * @export
 */
export const ChallengesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a personal challenge by product id and user challenge id
         * @summary Activate a personal challenges
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePersonalChallenge(app_id: string, challenge_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling activatePersonalChallenge.');
            }
            // verify required parameter 'challenge_id' is not null or undefined
            if (challenge_id === null || challenge_id === undefined) {
                throw new RequiredError('challenge_id','Required parameter challenge_id was null or undefined when calling activatePersonalChallenge.');
            }
            const localVarPath = `/api/v1/challenges/personal/activate/{appId}/{challengeId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challenge_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an active personal challenge by product id and user challenge id
         * @summary Cancel an active personal challenges
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPersonalChallenge(app_id: string, challenge_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling cancelPersonalChallenge.');
            }
            // verify required parameter 'challenge_id' is not null or undefined
            if (challenge_id === null || challenge_id === undefined) {
                throw new RequiredError('challenge_id','Required parameter challenge_id was null or undefined when calling cancelPersonalChallenge.');
            }
            const localVarPath = `/api/v1/challenges/personal/cancel/{appId}/{challengeId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challenge_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Claim the reward of a finished personal challenge by product id and user challenge id
         * @summary Claim the reward of a finished personal challenge
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPersonalChallengeReward(app_id: string, challenge_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling claimPersonalChallengeReward.');
            }
            // verify required parameter 'challenge_id' is not null or undefined
            if (challenge_id === null || challenge_id === undefined) {
                throw new RequiredError('challenge_id','Required parameter challenge_id was null or undefined when calling claimPersonalChallengeReward.');
            }
            const localVarPath = `/api/v1/challenges/personal/claim/{appId}/{challengeId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challenge_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an access token for the Websockets server notifying of updates in real time
         * @summary Get an access token for the Websockets server notifying of updates in real time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWebsocketAccessToken(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/challenges/web-socket/generate-token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get active personal challenges organized in categories
         * @summary Get active personal challenges
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePersonalChallenges(app_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getActivePersonalChallenges.');
            }
            const localVarPath = `/api/v1/challenges/personal/get-in-progress-challenges/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get personal challenges organized in categories that are not yet finished
         * @summary Get all personal challenges available for your app. Also includes completed challenges.
         * @param {string} app_id The app id
         * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
         * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getAllPersonalChallenges.');
            }
            const localVarPath = `/api/v1/challenges/personal/all/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (include_categories) {
                localVarQueryParameter['include_categories'] = include_categories.join(COLLECTION_FORMATS["csv"]);
            }

            if (exclude_categories) {
                localVarQueryParameter['exclude_categories'] = exclude_categories.join(COLLECTION_FORMATS["csv"]);
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get personal challenges organized in categories
         * @summary Get personal challenge by id
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalChallengeById(app_id: string, challenge_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getPersonalChallengeById.');
            }
            // verify required parameter 'challenge_id' is not null or undefined
            if (challenge_id === null || challenge_id === undefined) {
                throw new RequiredError('challenge_id','Required parameter challenge_id was null or undefined when calling getPersonalChallengeById.');
            }
            const localVarPath = `/api/v1/challenges/personal/get/{appId}/{challengeId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challenge_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get personal challenges organized in categories
         * @summary Get personal challenges that are not yet completed.
         * @param {string} app_id The app id
         * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
         * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getPersonalChallenges.');
            }
            const localVarPath = `/api/v1/challenges/personal/get/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (include_categories) {
                localVarQueryParameter['include_categories'] = include_categories.join(COLLECTION_FORMATS["csv"]);
            }

            if (exclude_categories) {
                localVarQueryParameter['exclude_categories'] = exclude_categories.join(COLLECTION_FORMATS["csv"]);
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get personal challenges organized in categories that are not yet finished
         * @summary Get personal challenges that are not yet completed.
         * @param {string} app_id The app id
         * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
         * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnresolvedPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling getUnresolvedPersonalChallenges.');
            }
            const localVarPath = `/api/v1/challenges/personal/unresolved/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (include_categories) {
                localVarQueryParameter['include_categories'] = include_categories.join(COLLECTION_FORMATS["csv"]);
            }

            if (exclude_categories) {
                localVarQueryParameter['exclude_categories'] = exclude_categories.join(COLLECTION_FORMATS["csv"]);
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets all challenges for the given app ID and user ID
         * @summary Resets all challenges for the given app ID and user ID
         * @param {string} app_id The app id
         * @param {string} user_id The user id (
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserAppChallenges(app_id: string, user_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling resetUserAppChallenges.');
            }
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling resetUserAppChallenges.');
            }
            const localVarPath = `/api/v1/reset-challenges/{appId}/{userId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlock a personal challenge by product id and challenge id
         * @summary Unlock a personal challenges
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockPersonalChallenge(app_id: string, challenge_id: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling unlockPersonalChallenge.');
            }
            // verify required parameter 'challenge_id' is not null or undefined
            if (challenge_id === null || challenge_id === undefined) {
                throw new RequiredError('challenge_id','Required parameter challenge_id was null or undefined when calling unlockPersonalChallenge.');
            }
            const localVarPath = `/api/v1/challenges/personal/unlock/{appId}/{challengeId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challenge_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChallengesApi - functional programming interface
 * @export
 */
export const ChallengesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Activate a personal challenge by product id and user challenge id
         * @summary Activate a personal challenges
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePersonalChallenge(app_id: string, challenge_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).activatePersonalChallenge(app_id, challenge_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancel an active personal challenge by product id and user challenge id
         * @summary Cancel an active personal challenges
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPersonalChallenge(app_id: string, challenge_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).cancelPersonalChallenge(app_id, challenge_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Claim the reward of a finished personal challenge by product id and user challenge id
         * @summary Claim the reward of a finished personal challenge
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPersonalChallengeReward(app_id: string, challenge_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).claimPersonalChallengeReward(app_id, challenge_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an access token for the Websockets server notifying of updates in real time
         * @summary Get an access token for the Websockets server notifying of updates in real time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWebsocketAccessToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SocketToken> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).generateWebsocketAccessToken(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get active personal challenges organized in categories
         * @summary Get active personal challenges
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePersonalChallenges(app_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChallengeCategory>> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).getActivePersonalChallenges(app_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get personal challenges organized in categories that are not yet finished
         * @summary Get all personal challenges available for your app. Also includes completed challenges.
         * @param {string} app_id The app id
         * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
         * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChallengeCategory>> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).getAllPersonalChallenges(app_id, include_categories, exclude_categories, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get personal challenges organized in categories
         * @summary Get personal challenge by id
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalChallengeById(app_id: string, challenge_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Challenge> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).getPersonalChallengeById(app_id, challenge_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get personal challenges organized in categories
         * @summary Get personal challenges that are not yet completed.
         * @param {string} app_id The app id
         * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
         * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChallengeCategory>> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).getPersonalChallenges(app_id, include_categories, exclude_categories, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get personal challenges organized in categories that are not yet finished
         * @summary Get personal challenges that are not yet completed.
         * @param {string} app_id The app id
         * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
         * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnresolvedPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChallengeCategory>> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).getUnresolvedPersonalChallenges(app_id, include_categories, exclude_categories, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resets all challenges for the given app ID and user ID
         * @summary Resets all challenges for the given app ID and user ID
         * @param {string} app_id The app id
         * @param {string} user_id The user id (
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserAppChallenges(app_id: string, user_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).resetUserAppChallenges(app_id, user_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unlock a personal challenge by product id and challenge id
         * @summary Unlock a personal challenges
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockPersonalChallenge(app_id: string, challenge_id: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = ChallengesApiFetchParamCreator(configuration).unlockPersonalChallenge(app_id, challenge_id, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChallengesApi - factory interface
 * @export
 */
export const ChallengesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Activate a personal challenge by product id and user challenge id
         * @summary Activate a personal challenges
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePersonalChallenge(app_id: string, challenge_id: string, language?: string, options?: any) {
            return ChallengesApiFp(configuration).activatePersonalChallenge(app_id, challenge_id, language, options)(fetch, basePath);
        },
        /**
         * Cancel an active personal challenge by product id and user challenge id
         * @summary Cancel an active personal challenges
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPersonalChallenge(app_id: string, challenge_id: string, language?: string, options?: any) {
            return ChallengesApiFp(configuration).cancelPersonalChallenge(app_id, challenge_id, language, options)(fetch, basePath);
        },
        /**
         * Claim the reward of a finished personal challenge by product id and user challenge id
         * @summary Claim the reward of a finished personal challenge
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPersonalChallengeReward(app_id: string, challenge_id: string, language?: string, options?: any) {
            return ChallengesApiFp(configuration).claimPersonalChallengeReward(app_id, challenge_id, language, options)(fetch, basePath);
        },
        /**
         * Get an access token for the Websockets server notifying of updates in real time
         * @summary Get an access token for the Websockets server notifying of updates in real time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWebsocketAccessToken(options?: any) {
            return ChallengesApiFp(configuration).generateWebsocketAccessToken(options)(fetch, basePath);
        },
        /**
         * Get active personal challenges organized in categories
         * @summary Get active personal challenges
         * @param {string} app_id The app id
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePersonalChallenges(app_id: string, language?: string, options?: any) {
            return ChallengesApiFp(configuration).getActivePersonalChallenges(app_id, language, options)(fetch, basePath);
        },
        /**
         * Get personal challenges organized in categories that are not yet finished
         * @summary Get all personal challenges available for your app. Also includes completed challenges.
         * @param {string} app_id The app id
         * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
         * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options?: any) {
            return ChallengesApiFp(configuration).getAllPersonalChallenges(app_id, include_categories, exclude_categories, language, options)(fetch, basePath);
        },
        /**
         * Get personal challenges organized in categories
         * @summary Get personal challenge by id
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalChallengeById(app_id: string, challenge_id: string, language?: string, options?: any) {
            return ChallengesApiFp(configuration).getPersonalChallengeById(app_id, challenge_id, language, options)(fetch, basePath);
        },
        /**
         * Get personal challenges organized in categories
         * @summary Get personal challenges that are not yet completed.
         * @param {string} app_id The app id
         * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
         * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options?: any) {
            return ChallengesApiFp(configuration).getPersonalChallenges(app_id, include_categories, exclude_categories, language, options)(fetch, basePath);
        },
        /**
         * Get personal challenges organized in categories that are not yet finished
         * @summary Get personal challenges that are not yet completed.
         * @param {string} app_id The app id
         * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
         * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnresolvedPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options?: any) {
            return ChallengesApiFp(configuration).getUnresolvedPersonalChallenges(app_id, include_categories, exclude_categories, language, options)(fetch, basePath);
        },
        /**
         * Resets all challenges for the given app ID and user ID
         * @summary Resets all challenges for the given app ID and user ID
         * @param {string} app_id The app id
         * @param {string} user_id The user id (
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserAppChallenges(app_id: string, user_id: string, options?: any) {
            return ChallengesApiFp(configuration).resetUserAppChallenges(app_id, user_id, options)(fetch, basePath);
        },
        /**
         * Unlock a personal challenge by product id and challenge id
         * @summary Unlock a personal challenges
         * @param {string} app_id The app id
         * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockPersonalChallenge(app_id: string, challenge_id: string, language?: string, options?: any) {
            return ChallengesApiFp(configuration).unlockPersonalChallenge(app_id, challenge_id, language, options)(fetch, basePath);
        },
    };
};

/**
 * ChallengesApi - object-oriented interface
 * @export
 * @class ChallengesApi
 * @extends {BaseAPI}
 */
export class ChallengesApi extends BaseAPI {
    /**
     * Activate a personal challenge by product id and user challenge id
     * @summary Activate a personal challenges
     * @param {string} app_id The app id
     * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public activatePersonalChallenge(app_id: string, challenge_id: string, language?: string, options?: any) {
        return ChallengesApiFp(this.configuration).activatePersonalChallenge(app_id, challenge_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Cancel an active personal challenge by product id and user challenge id
     * @summary Cancel an active personal challenges
     * @param {string} app_id The app id
     * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public cancelPersonalChallenge(app_id: string, challenge_id: string, language?: string, options?: any) {
        return ChallengesApiFp(this.configuration).cancelPersonalChallenge(app_id, challenge_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Claim the reward of a finished personal challenge by product id and user challenge id
     * @summary Claim the reward of a finished personal challenge
     * @param {string} app_id The app id
     * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public claimPersonalChallengeReward(app_id: string, challenge_id: string, language?: string, options?: any) {
        return ChallengesApiFp(this.configuration).claimPersonalChallengeReward(app_id, challenge_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get an access token for the Websockets server notifying of updates in real time
     * @summary Get an access token for the Websockets server notifying of updates in real time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public generateWebsocketAccessToken(options?: any) {
        return ChallengesApiFp(this.configuration).generateWebsocketAccessToken(options)(this.fetch, this.basePath);
    }

    /**
     * Get active personal challenges organized in categories
     * @summary Get active personal challenges
     * @param {string} app_id The app id
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public getActivePersonalChallenges(app_id: string, language?: string, options?: any) {
        return ChallengesApiFp(this.configuration).getActivePersonalChallenges(app_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get personal challenges organized in categories that are not yet finished
     * @summary Get all personal challenges available for your app. Also includes completed challenges.
     * @param {string} app_id The app id
     * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
     * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public getAllPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options?: any) {
        return ChallengesApiFp(this.configuration).getAllPersonalChallenges(app_id, include_categories, exclude_categories, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get personal challenges organized in categories
     * @summary Get personal challenge by id
     * @param {string} app_id The app id
     * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public getPersonalChallengeById(app_id: string, challenge_id: string, language?: string, options?: any) {
        return ChallengesApiFp(this.configuration).getPersonalChallengeById(app_id, challenge_id, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get personal challenges organized in categories
     * @summary Get personal challenges that are not yet completed.
     * @param {string} app_id The app id
     * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
     * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public getPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options?: any) {
        return ChallengesApiFp(this.configuration).getPersonalChallenges(app_id, include_categories, exclude_categories, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get personal challenges organized in categories that are not yet finished
     * @summary Get personal challenges that are not yet completed.
     * @param {string} app_id The app id
     * @param {Array<string>} [include_categories] A list of categories that should be included in the response. Only the categories provided will be returned
     * @param {Array<string>} [exclude_categories] A list of categories that should be excluded from the response. All  categories except those listed here will be returned
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public getUnresolvedPersonalChallenges(app_id: string, include_categories?: Array<string>, exclude_categories?: Array<string>, language?: string, options?: any) {
        return ChallengesApiFp(this.configuration).getUnresolvedPersonalChallenges(app_id, include_categories, exclude_categories, language, options)(this.fetch, this.basePath);
    }

    /**
     * Resets all challenges for the given app ID and user ID
     * @summary Resets all challenges for the given app ID and user ID
     * @param {string} app_id The app id
     * @param {string} user_id The user id (
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public resetUserAppChallenges(app_id: string, user_id: string, options?: any) {
        return ChallengesApiFp(this.configuration).resetUserAppChallenges(app_id, user_id, options)(this.fetch, this.basePath);
    }

    /**
     * Unlock a personal challenge by product id and challenge id
     * @summary Unlock a personal challenges
     * @param {string} app_id The app id
     * @param {string} challenge_id The challenge id (see challenge_id of Challenge object)
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public unlockPersonalChallenge(app_id: string, challenge_id: string, language?: string, options?: any) {
        return ChallengesApiFp(this.configuration).unlockPersonalChallenge(app_id, challenge_id, language, options)(this.fetch, this.basePath);
    }

}
/**
 * EventsApi - fetch parameter creator
 * @export
 */
export const EventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all available events and required and optional properties
         * @summary Get all available events and required and optional properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableEvents(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/public/documentation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post an event to the SCILL backend
         * @summary Post an event
         * @param {EventPayload} body Event payload or team event payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEvent(body: EventPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendEvent.');
            }
            const localVarPath = `/api/v1/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyType required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("auth")
					: configuration.apiKey;
                localVarQueryParameter["auth"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all available events and required and optional properties
         * @summary Get all available events and required and optional properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableEvents(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventDescription>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).getAvailableEvents(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post an event to the SCILL backend
         * @summary Post an event
         * @param {EventPayload} body Event payload or team event payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEvent(body: EventPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).sendEvent(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all available events and required and optional properties
         * @summary Get all available events and required and optional properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableEvents(options?: any) {
            return EventsApiFp(configuration).getAvailableEvents(options)(fetch, basePath);
        },
        /**
         * Post an event to the SCILL backend
         * @summary Post an event
         * @param {EventPayload} body Event payload or team event payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEvent(body: EventPayload, options?: any) {
            return EventsApiFp(configuration).sendEvent(body, options)(fetch, basePath);
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Get all available events and required and optional properties
     * @summary Get all available events and required and optional properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAvailableEvents(options?: any) {
        return EventsApiFp(this.configuration).getAvailableEvents(options)(this.fetch, this.basePath);
    }

    /**
     * Post an event to the SCILL backend
     * @summary Post an event
     * @param {EventPayload} body Event payload or team event payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public sendEvent(body: EventPayload, options?: any) {
        return EventsApiFp(this.configuration).sendEvent(body, options)(this.fetch, this.basePath);
    }

}
/**
 * LeaderboardsApi - fetch parameter creator
 * @export
 */
export const LeaderboardsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides the current leaderboard rankings for a specific leaderboard.
         * @summary Retrieve Leaderboard
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard(leaderboard_id: string, current_page?: number, page_size?: number, start_date?: string, end_date?: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'leaderboard_id' is not null or undefined
            if (leaderboard_id === null || leaderboard_id === undefined) {
                throw new RequiredError('leaderboard_id','Required parameter leaderboard_id was null or undefined when calling getLeaderboard.');
            }
            const localVarPath = `/api/v1/leaderboards/{leaderboardId}`
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboard_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (current_page !== undefined) {
                localVarQueryParameter['currentPage'] = current_page;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['pageSize'] = page_size;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['startDate'] = start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['endDate'] = end_date;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a LeaderboardMemberRanking item for the specified leaderboard. Use this route to get the position of a user of team in a specified leaderboard.
         * @summary Retrieve User Ranking
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRanking(member_type: string, member_id: string, leaderboard_id: string, start_date?: string, end_date?: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'member_type' is not null or undefined
            if (member_type === null || member_type === undefined) {
                throw new RequiredError('member_type','Required parameter member_type was null or undefined when calling getLeaderboardRanking.');
            }
            // verify required parameter 'member_id' is not null or undefined
            if (member_id === null || member_id === undefined) {
                throw new RequiredError('member_id','Required parameter member_id was null or undefined when calling getLeaderboardRanking.');
            }
            // verify required parameter 'leaderboard_id' is not null or undefined
            if (leaderboard_id === null || leaderboard_id === undefined) {
                throw new RequiredError('leaderboard_id','Required parameter leaderboard_id was null or undefined when calling getLeaderboardRanking.');
            }
            const localVarPath = `/api/v1/leaderboards-members/{memberType}/{memberId}/{leaderboardId}`
                .replace(`{${"memberType"}}`, encodeURIComponent(String(member_type)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(member_id)))
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboard_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['startDate'] = start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['endDate'] = end_date;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of LeaderboardRanking items defined for all leaderboards in the application specified for the user. If the member is not in the leaderboard, the rank will be -1 in the LeaderboardRanking object.
         * @summary Retrieve User Rankings
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRankings(member_type: string, member_id: string, start_date?: string, end_date?: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'member_type' is not null or undefined
            if (member_type === null || member_type === undefined) {
                throw new RequiredError('member_type','Required parameter member_type was null or undefined when calling getLeaderboardRankings.');
            }
            // verify required parameter 'member_id' is not null or undefined
            if (member_id === null || member_id === undefined) {
                throw new RequiredError('member_id','Required parameter member_id was null or undefined when calling getLeaderboardRankings.');
            }
            const localVarPath = `/api/v1/leaderboards-members/{memberType}/{memberId}`
                .replace(`{${"memberType"}}`, encodeURIComponent(String(member_type)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(member_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['startDate'] = start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['endDate'] = end_date;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Leaderboard items defined for the application.
         * @summary Retrieve Leaderboards
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboards(current_page?: number, page_size?: number, start_date?: string, end_date?: string, language?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/leaderboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (current_page !== undefined) {
                localVarQueryParameter['currentPage'] = current_page;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['pageSize'] = page_size;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['startDate'] = start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['endDate'] = end_date;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all leaderboard data, i.e. reset the leaderboard for the specified member.
         * @summary Delete all leaderboard data, i.e. reset the leaderboard for the specified member.
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} app_id The application ID
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLeaderboardRankings(member_type: string, app_id: string, member_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'member_type' is not null or undefined
            if (member_type === null || member_type === undefined) {
                throw new RequiredError('member_type','Required parameter member_type was null or undefined when calling resetLeaderboardRankings.');
            }
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling resetLeaderboardRankings.');
            }
            // verify required parameter 'member_id' is not null or undefined
            if (member_id === null || member_id === undefined) {
                throw new RequiredError('member_id','Required parameter member_id was null or undefined when calling resetLeaderboardRankings.');
            }
            const localVarPath = `/api/v1/reset-leaderboard/{memberType}/{appId}/{memberId}`
                .replace(`{${"memberType"}}`, encodeURIComponent(String(member_type)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(member_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardsApi - functional programming interface
 * @export
 */
export const LeaderboardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides the current leaderboard rankings for a specific leaderboard.
         * @summary Retrieve Leaderboard
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard(leaderboard_id: string, current_page?: number, page_size?: number, start_date?: string, end_date?: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Leaderboard> {
            const localVarFetchArgs = LeaderboardsApiFetchParamCreator(configuration).getLeaderboard(leaderboard_id, current_page, page_size, start_date, end_date, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a LeaderboardMemberRanking item for the specified leaderboard. Use this route to get the position of a user of team in a specified leaderboard.
         * @summary Retrieve User Ranking
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRanking(member_type: string, member_id: string, leaderboard_id: string, start_date?: string, end_date?: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardMemberRanking> {
            const localVarFetchArgs = LeaderboardsApiFetchParamCreator(configuration).getLeaderboardRanking(member_type, member_id, leaderboard_id, start_date, end_date, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an array of LeaderboardRanking items defined for all leaderboards in the application specified for the user. If the member is not in the leaderboard, the rank will be -1 in the LeaderboardRanking object.
         * @summary Retrieve User Rankings
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRankings(member_type: string, member_id: string, start_date?: string, end_date?: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LeaderboardMemberRanking>> {
            const localVarFetchArgs = LeaderboardsApiFetchParamCreator(configuration).getLeaderboardRankings(member_type, member_id, start_date, end_date, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an array of Leaderboard items defined for the application.
         * @summary Retrieve Leaderboards
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboards(current_page?: number, page_size?: number, start_date?: string, end_date?: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Leaderboard>> {
            const localVarFetchArgs = LeaderboardsApiFetchParamCreator(configuration).getLeaderboards(current_page, page_size, start_date, end_date, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete all leaderboard data, i.e. reset the leaderboard for the specified member.
         * @summary Delete all leaderboard data, i.e. reset the leaderboard for the specified member.
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} app_id The application ID
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLeaderboardRankings(member_type: string, app_id: string, member_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = LeaderboardsApiFetchParamCreator(configuration).resetLeaderboardRankings(member_type, app_id, member_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LeaderboardsApi - factory interface
 * @export
 */
export const LeaderboardsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Provides the current leaderboard rankings for a specific leaderboard.
         * @summary Retrieve Leaderboard
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard(leaderboard_id: string, current_page?: number, page_size?: number, start_date?: string, end_date?: string, language?: string, options?: any) {
            return LeaderboardsApiFp(configuration).getLeaderboard(leaderboard_id, current_page, page_size, start_date, end_date, language, options)(fetch, basePath);
        },
        /**
         * Returns a LeaderboardMemberRanking item for the specified leaderboard. Use this route to get the position of a user of team in a specified leaderboard.
         * @summary Retrieve User Ranking
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRanking(member_type: string, member_id: string, leaderboard_id: string, start_date?: string, end_date?: string, language?: string, options?: any) {
            return LeaderboardsApiFp(configuration).getLeaderboardRanking(member_type, member_id, leaderboard_id, start_date, end_date, language, options)(fetch, basePath);
        },
        /**
         * Returns an array of LeaderboardRanking items defined for all leaderboards in the application specified for the user. If the member is not in the leaderboard, the rank will be -1 in the LeaderboardRanking object.
         * @summary Retrieve User Rankings
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRankings(member_type: string, member_id: string, start_date?: string, end_date?: string, language?: string, options?: any) {
            return LeaderboardsApiFp(configuration).getLeaderboardRankings(member_type, member_id, start_date, end_date, language, options)(fetch, basePath);
        },
        /**
         * Returns an array of Leaderboard items defined for the application.
         * @summary Retrieve Leaderboards
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboards(current_page?: number, page_size?: number, start_date?: string, end_date?: string, language?: string, options?: any) {
            return LeaderboardsApiFp(configuration).getLeaderboards(current_page, page_size, start_date, end_date, language, options)(fetch, basePath);
        },
        /**
         * Delete all leaderboard data, i.e. reset the leaderboard for the specified member.
         * @summary Delete all leaderboard data, i.e. reset the leaderboard for the specified member.
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} app_id The application ID
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLeaderboardRankings(member_type: string, app_id: string, member_id: string, options?: any) {
            return LeaderboardsApiFp(configuration).resetLeaderboardRankings(member_type, app_id, member_id, options)(fetch, basePath);
        },
    };
};

/**
 * LeaderboardsApi - object-oriented interface
 * @export
 * @class LeaderboardsApi
 * @extends {BaseAPI}
 */
export class LeaderboardsApi extends BaseAPI {
    /**
     * Provides the current leaderboard rankings for a specific leaderboard.
     * @summary Retrieve Leaderboard
     * @param {string} leaderboard_id The id of the leaderboard
     * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
     * @param {number} [page_size] The number of elements per page. Default is 25.
     * @param {string} [start_date] The starting date for fetching results.
     * @param {string} [end_date] The ending date for fetching results.
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public getLeaderboard(leaderboard_id: string, current_page?: number, page_size?: number, start_date?: string, end_date?: string, language?: string, options?: any) {
        return LeaderboardsApiFp(this.configuration).getLeaderboard(leaderboard_id, current_page, page_size, start_date, end_date, language, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a LeaderboardMemberRanking item for the specified leaderboard. Use this route to get the position of a user of team in a specified leaderboard.
     * @summary Retrieve User Ranking
     * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
     * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
     * @param {string} leaderboard_id The id of the leaderboard
     * @param {string} [start_date] The starting date for fetching results.
     * @param {string} [end_date] The ending date for fetching results.
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public getLeaderboardRanking(member_type: string, member_id: string, leaderboard_id: string, start_date?: string, end_date?: string, language?: string, options?: any) {
        return LeaderboardsApiFp(this.configuration).getLeaderboardRanking(member_type, member_id, leaderboard_id, start_date, end_date, language, options)(this.fetch, this.basePath);
    }

    /**
     * Returns an array of LeaderboardRanking items defined for all leaderboards in the application specified for the user. If the member is not in the leaderboard, the rank will be -1 in the LeaderboardRanking object.
     * @summary Retrieve User Rankings
     * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
     * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
     * @param {string} [start_date] The starting date for fetching results.
     * @param {string} [end_date] The ending date for fetching results.
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public getLeaderboardRankings(member_type: string, member_id: string, start_date?: string, end_date?: string, language?: string, options?: any) {
        return LeaderboardsApiFp(this.configuration).getLeaderboardRankings(member_type, member_id, start_date, end_date, language, options)(this.fetch, this.basePath);
    }

    /**
     * Returns an array of Leaderboard items defined for the application.
     * @summary Retrieve Leaderboards
     * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
     * @param {number} [page_size] The number of elements per page. Default is 25.
     * @param {string} [start_date] The starting date for fetching results.
     * @param {string} [end_date] The ending date for fetching results.
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public getLeaderboards(current_page?: number, page_size?: number, start_date?: string, end_date?: string, language?: string, options?: any) {
        return LeaderboardsApiFp(this.configuration).getLeaderboards(current_page, page_size, start_date, end_date, language, options)(this.fetch, this.basePath);
    }

    /**
     * Delete all leaderboard data, i.e. reset the leaderboard for the specified member.
     * @summary Delete all leaderboard data, i.e. reset the leaderboard for the specified member.
     * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
     * @param {string} app_id The application ID
     * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public resetLeaderboardRankings(member_type: string, app_id: string, member_id: string, options?: any) {
        return LeaderboardsApiFp(this.configuration).resetLeaderboardRankings(member_type, app_id, member_id, options)(this.fetch, this.basePath);
    }

}
/**
 * LeaderboardsV2Api - fetch parameter creator
 * @export
 */
export const LeaderboardsV2ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides the selected leaderboard V2 rankings for a specific leaderboard.
         * @summary Retrieve Leaderboard
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [current_position] The starting leaderboard position from which the results should be loaded. The number of results is controlled via the pageSize variable. This parameter overrides the currentPage parameter.
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardV2(leaderboard_id: string, start_date?: string, end_date?: string, aggregate?: string, current_page?: number, current_position?: number, page_size?: number, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'leaderboard_id' is not null or undefined
            if (leaderboard_id === null || leaderboard_id === undefined) {
                throw new RequiredError('leaderboard_id','Required parameter leaderboard_id was null or undefined when calling getLeaderboardV2.');
            }
            const localVarPath = `/api/v2/leaderboards/{leaderboardId}`
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboard_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['startDate'] = start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['endDate'] = end_date;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (current_page !== undefined) {
                localVarQueryParameter['currentPage'] = current_page;
            }

            if (current_position !== undefined) {
                localVarQueryParameter['currentPosition'] = current_position;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['pageSize'] = page_size;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a LeaderboardV2MemberRanking item for the specified leaderboard. Use this route to get the position of a user of team in a specified leaderboard.
         * @summary Retrieve user ranking for a single leaderboard V2
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardV2Ranking(member_type: string, member_id: string, leaderboard_id: string, start_date?: string, end_date?: string, aggregate?: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'member_type' is not null or undefined
            if (member_type === null || member_type === undefined) {
                throw new RequiredError('member_type','Required parameter member_type was null or undefined when calling getLeaderboardV2Ranking.');
            }
            // verify required parameter 'member_id' is not null or undefined
            if (member_id === null || member_id === undefined) {
                throw new RequiredError('member_id','Required parameter member_id was null or undefined when calling getLeaderboardV2Ranking.');
            }
            // verify required parameter 'leaderboard_id' is not null or undefined
            if (leaderboard_id === null || leaderboard_id === undefined) {
                throw new RequiredError('leaderboard_id','Required parameter leaderboard_id was null or undefined when calling getLeaderboardV2Ranking.');
            }
            const localVarPath = `/api/v2/leaderboards-members/{memberType}/{memberId}/{leaderboardId}`
                .replace(`{${"memberType"}}`, encodeURIComponent(String(member_type)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(member_id)))
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboard_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['startDate'] = start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['endDate'] = end_date;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of LeaderboardV2MemberRanking items defined for all leaderboards in the application specified for the user. If the member is not in the leaderboard, the rank will be -1 in the LeaderboardRanking object.
         * @summary Retrieve user rankings across all leaderboards
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardV2Rankings(member_type: string, member_id: string, start_date?: string, end_date?: string, aggregate?: string, language?: string, options: any = {}): FetchArgs {
            // verify required parameter 'member_type' is not null or undefined
            if (member_type === null || member_type === undefined) {
                throw new RequiredError('member_type','Required parameter member_type was null or undefined when calling getLeaderboardV2Rankings.');
            }
            // verify required parameter 'member_id' is not null or undefined
            if (member_id === null || member_id === undefined) {
                throw new RequiredError('member_id','Required parameter member_id was null or undefined when calling getLeaderboardV2Rankings.');
            }
            const localVarPath = `/api/v2/leaderboards-members/{memberType}/{memberId}`
                .replace(`{${"memberType"}}`, encodeURIComponent(String(member_type)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(member_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['startDate'] = start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['endDate'] = end_date;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of LeaderboardV2Results items defined for the application.
         * @summary Retrieve Leaderboards
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [current_position] The starting leaderboard position from which the results should be loaded. The number of results is controlled via the pageSize variable. This parameter overrides the currentPage parameter.
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardsV2(start_date?: string, end_date?: string, aggregate?: string, current_page?: number, current_position?: number, page_size?: number, language?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/leaderboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['startDate'] = start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['endDate'] = end_date;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (current_page !== undefined) {
                localVarQueryParameter['currentPage'] = current_page;
            }

            if (current_position !== undefined) {
                localVarQueryParameter['currentPosition'] = current_position;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['pageSize'] = page_size;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all leaderboard V2 data, i.e. reset the leaderboard V2.
         * @summary Deletes all leaderboard V2 data, i.e. reset the leaderboard V2.
         * @param {string} app_id The application ID
         * @param {string} leaderboard_id The leaderboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLeaderboardV2Rankings(app_id: string, leaderboard_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'app_id' is not null or undefined
            if (app_id === null || app_id === undefined) {
                throw new RequiredError('app_id','Required parameter app_id was null or undefined when calling resetLeaderboardV2Rankings.');
            }
            // verify required parameter 'leaderboard_id' is not null or undefined
            if (leaderboard_id === null || leaderboard_id === undefined) {
                throw new RequiredError('leaderboard_id','Required parameter leaderboard_id was null or undefined when calling resetLeaderboardV2Rankings.');
            }
            const localVarPath = `/api/v2/leaderboards-reset/{appId}/{leaderboardId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(app_id)))
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboard_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication oAuthNoScopes required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuthNoScopes", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardsV2Api - functional programming interface
 * @export
 */
export const LeaderboardsV2ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides the selected leaderboard V2 rankings for a specific leaderboard.
         * @summary Retrieve Leaderboard
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [current_position] The starting leaderboard position from which the results should be loaded. The number of results is controlled via the pageSize variable. This parameter overrides the currentPage parameter.
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardV2(leaderboard_id: string, start_date?: string, end_date?: string, aggregate?: string, current_page?: number, current_position?: number, page_size?: number, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardV2Results> {
            const localVarFetchArgs = LeaderboardsV2ApiFetchParamCreator(configuration).getLeaderboardV2(leaderboard_id, start_date, end_date, aggregate, current_page, current_position, page_size, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a LeaderboardV2MemberRanking item for the specified leaderboard. Use this route to get the position of a user of team in a specified leaderboard.
         * @summary Retrieve user ranking for a single leaderboard V2
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardV2Ranking(member_type: string, member_id: string, leaderboard_id: string, start_date?: string, end_date?: string, aggregate?: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardV2MemberRanking> {
            const localVarFetchArgs = LeaderboardsV2ApiFetchParamCreator(configuration).getLeaderboardV2Ranking(member_type, member_id, leaderboard_id, start_date, end_date, aggregate, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an array of LeaderboardV2MemberRanking items defined for all leaderboards in the application specified for the user. If the member is not in the leaderboard, the rank will be -1 in the LeaderboardRanking object.
         * @summary Retrieve user rankings across all leaderboards
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardV2Rankings(member_type: string, member_id: string, start_date?: string, end_date?: string, aggregate?: string, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LeaderboardV2MemberRanking>> {
            const localVarFetchArgs = LeaderboardsV2ApiFetchParamCreator(configuration).getLeaderboardV2Rankings(member_type, member_id, start_date, end_date, aggregate, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an array of LeaderboardV2Results items defined for the application.
         * @summary Retrieve Leaderboards
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [current_position] The starting leaderboard position from which the results should be loaded. The number of results is controlled via the pageSize variable. This parameter overrides the currentPage parameter.
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardsV2(start_date?: string, end_date?: string, aggregate?: string, current_page?: number, current_position?: number, page_size?: number, language?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LeaderboardV2Results>> {
            const localVarFetchArgs = LeaderboardsV2ApiFetchParamCreator(configuration).getLeaderboardsV2(start_date, end_date, aggregate, current_page, current_position, page_size, language, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes all leaderboard V2 data, i.e. reset the leaderboard V2.
         * @summary Deletes all leaderboard V2 data, i.e. reset the leaderboard V2.
         * @param {string} app_id The application ID
         * @param {string} leaderboard_id The leaderboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLeaderboardV2Rankings(app_id: string, leaderboard_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActionResponse> {
            const localVarFetchArgs = LeaderboardsV2ApiFetchParamCreator(configuration).resetLeaderboardV2Rankings(app_id, leaderboard_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LeaderboardsV2Api - factory interface
 * @export
 */
export const LeaderboardsV2ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Provides the selected leaderboard V2 rankings for a specific leaderboard.
         * @summary Retrieve Leaderboard
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [current_position] The starting leaderboard position from which the results should be loaded. The number of results is controlled via the pageSize variable. This parameter overrides the currentPage parameter.
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardV2(leaderboard_id: string, start_date?: string, end_date?: string, aggregate?: string, current_page?: number, current_position?: number, page_size?: number, language?: string, options?: any) {
            return LeaderboardsV2ApiFp(configuration).getLeaderboardV2(leaderboard_id, start_date, end_date, aggregate, current_page, current_position, page_size, language, options)(fetch, basePath);
        },
        /**
         * Returns a LeaderboardV2MemberRanking item for the specified leaderboard. Use this route to get the position of a user of team in a specified leaderboard.
         * @summary Retrieve user ranking for a single leaderboard V2
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} leaderboard_id The id of the leaderboard
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardV2Ranking(member_type: string, member_id: string, leaderboard_id: string, start_date?: string, end_date?: string, aggregate?: string, language?: string, options?: any) {
            return LeaderboardsV2ApiFp(configuration).getLeaderboardV2Ranking(member_type, member_id, leaderboard_id, start_date, end_date, aggregate, language, options)(fetch, basePath);
        },
        /**
         * Returns an array of LeaderboardV2MemberRanking items defined for all leaderboards in the application specified for the user. If the member is not in the leaderboard, the rank will be -1 in the LeaderboardRanking object.
         * @summary Retrieve user rankings across all leaderboards
         * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
         * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardV2Rankings(member_type: string, member_id: string, start_date?: string, end_date?: string, aggregate?: string, language?: string, options?: any) {
            return LeaderboardsV2ApiFp(configuration).getLeaderboardV2Rankings(member_type, member_id, start_date, end_date, aggregate, language, options)(fetch, basePath);
        },
        /**
         * Returns an array of LeaderboardV2Results items defined for the application.
         * @summary Retrieve Leaderboards
         * @param {string} [start_date] The starting date for fetching results.
         * @param {string} [end_date] The ending date for fetching results.
         * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
         * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
         * @param {number} [current_position] The starting leaderboard position from which the results should be loaded. The number of results is controlled via the pageSize variable. This parameter overrides the currentPage parameter.
         * @param {number} [page_size] The number of elements per page. Default is 25.
         * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardsV2(start_date?: string, end_date?: string, aggregate?: string, current_page?: number, current_position?: number, page_size?: number, language?: string, options?: any) {
            return LeaderboardsV2ApiFp(configuration).getLeaderboardsV2(start_date, end_date, aggregate, current_page, current_position, page_size, language, options)(fetch, basePath);
        },
        /**
         * Deletes all leaderboard V2 data, i.e. reset the leaderboard V2.
         * @summary Deletes all leaderboard V2 data, i.e. reset the leaderboard V2.
         * @param {string} app_id The application ID
         * @param {string} leaderboard_id The leaderboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLeaderboardV2Rankings(app_id: string, leaderboard_id: string, options?: any) {
            return LeaderboardsV2ApiFp(configuration).resetLeaderboardV2Rankings(app_id, leaderboard_id, options)(fetch, basePath);
        },
    };
};

/**
 * LeaderboardsV2Api - object-oriented interface
 * @export
 * @class LeaderboardsV2Api
 * @extends {BaseAPI}
 */
export class LeaderboardsV2Api extends BaseAPI {
    /**
     * Provides the selected leaderboard V2 rankings for a specific leaderboard.
     * @summary Retrieve Leaderboard
     * @param {string} leaderboard_id The id of the leaderboard
     * @param {string} [start_date] The starting date for fetching results.
     * @param {string} [end_date] The ending date for fetching results.
     * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
     * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
     * @param {number} [current_position] The starting leaderboard position from which the results should be loaded. The number of results is controlled via the pageSize variable. This parameter overrides the currentPage parameter.
     * @param {number} [page_size] The number of elements per page. Default is 25.
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsV2Api
     */
    public getLeaderboardV2(leaderboard_id: string, start_date?: string, end_date?: string, aggregate?: string, current_page?: number, current_position?: number, page_size?: number, language?: string, options?: any) {
        return LeaderboardsV2ApiFp(this.configuration).getLeaderboardV2(leaderboard_id, start_date, end_date, aggregate, current_page, current_position, page_size, language, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a LeaderboardV2MemberRanking item for the specified leaderboard. Use this route to get the position of a user of team in a specified leaderboard.
     * @summary Retrieve user ranking for a single leaderboard V2
     * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
     * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
     * @param {string} leaderboard_id The id of the leaderboard
     * @param {string} [start_date] The starting date for fetching results.
     * @param {string} [end_date] The ending date for fetching results.
     * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsV2Api
     */
    public getLeaderboardV2Ranking(member_type: string, member_id: string, leaderboard_id: string, start_date?: string, end_date?: string, aggregate?: string, language?: string, options?: any) {
        return LeaderboardsV2ApiFp(this.configuration).getLeaderboardV2Ranking(member_type, member_id, leaderboard_id, start_date, end_date, aggregate, language, options)(this.fetch, this.basePath);
    }

    /**
     * Returns an array of LeaderboardV2MemberRanking items defined for all leaderboards in the application specified for the user. If the member is not in the leaderboard, the rank will be -1 in the LeaderboardRanking object.
     * @summary Retrieve user rankings across all leaderboards
     * @param {string} member_type The member type, can be user or team (right now) and sets which leaderboards should be selected.
     * @param {string} member_id Either the user_id or team_id you used when sending the events. The memberType flag identifies which one is used.
     * @param {string} [start_date] The starting date for fetching results.
     * @param {string} [end_date] The ending date for fetching results.
     * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsV2Api
     */
    public getLeaderboardV2Rankings(member_type: string, member_id: string, start_date?: string, end_date?: string, aggregate?: string, language?: string, options?: any) {
        return LeaderboardsV2ApiFp(this.configuration).getLeaderboardV2Rankings(member_type, member_id, start_date, end_date, aggregate, language, options)(this.fetch, this.basePath);
    }

    /**
     * Returns an array of LeaderboardV2Results items defined for the application.
     * @summary Retrieve Leaderboards
     * @param {string} [start_date] The starting date for fetching results.
     * @param {string} [end_date] The ending date for fetching results.
     * @param {string} [aggregate] The aggregate function for the calculation of the results - can be BEST (returns a single score - either the lowest if ASC sorting is used, or the highest if DESC is used) or SUM (default value - increments (sums up) the scores).
     * @param {number} [current_page] The page index starting at 1. The number of pageSize elements are returned for each page. Default value is 1
     * @param {number} [current_position] The starting leaderboard position from which the results should be loaded. The number of results is controlled via the pageSize variable. This parameter overrides the currentPage parameter.
     * @param {number} [page_size] The number of elements per page. Default is 25.
     * @param {string} [language] Set the language. Content can be translated in the Admin Panel. Values can be international language codes like de, en, fr, it, ...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsV2Api
     */
    public getLeaderboardsV2(start_date?: string, end_date?: string, aggregate?: string, current_page?: number, current_position?: number, page_size?: number, language?: string, options?: any) {
        return LeaderboardsV2ApiFp(this.configuration).getLeaderboardsV2(start_date, end_date, aggregate, current_page, current_position, page_size, language, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes all leaderboard V2 data, i.e. reset the leaderboard V2.
     * @summary Deletes all leaderboard V2 data, i.e. reset the leaderboard V2.
     * @param {string} app_id The application ID
     * @param {string} leaderboard_id The leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsV2Api
     */
    public resetLeaderboardV2Rankings(app_id: string, leaderboard_id: string, options?: any) {
        return LeaderboardsV2ApiFp(this.configuration).resetLeaderboardV2Rankings(app_id, leaderboard_id, options)(this.fetch, this.basePath);
    }

}
